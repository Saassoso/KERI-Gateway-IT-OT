<html lang="en"><head><script>'use strict';var h=typeof Object.defineProperties=="function"?Object.defineProperty:function(a,b,d){if(a==Array.prototype||a==Object.prototype)return a;a[b]=d.value;return a};function l(a){a=["object"==typeof globalThis&&globalThis,a,"object"==typeof window&&window,"object"==typeof self&&self,"object"==typeof global&&global];for(var b=0;b<a.length;++b){var d=a[b];if(d&&d.Math==Math)return d}throw Error("Cannot find global object");}var n=l(this);
function p(a,b){if(b)a:{var d=n;a=a.split(".");for(var c=0;c<a.length-1;c++){var e=a[c];if(!(e in d))break a;d=d[e]}a=a[a.length-1];c=d[a];b=b(c);b!=c&&b!=null&&h(d,a,{configurable:!0,writable:!0,value:b})}}function r(a){function b(c){return a.next(c)}function d(c){return a.throw(c)}return new Promise(function(c,e){function f(g){g.done?c(g.value):Promise.resolve(g.value).then(b,d).then(f,e)}f(a.next())})}function t(a){return r(a())}
p("Object.values",function(a){return a?a:function(b){var d=[],c;for(c in b)Object.prototype.hasOwnProperty.call(b,c)&&d.push(b[c]);return d}});p("Array.prototype.includes",function(a){return a?a:function(b,d){var c=this;c instanceof String&&(c=String(c));var e=c.length;d=d||0;for(d<0&&(d=Math.max(d+e,0));d<e;d++){var f=c[d];if(f===b||Object.is(f,b))return!0}return!1}});/*

 MIT License

 Copyright (c) 2017-2023 W.Y.

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.

*/
function u(a,b){const d=a.style;b.backgroundColor&&(d.backgroundColor=b.backgroundColor);b.width&&(d.width=`${b.width}px`);b.height&&(d.height=`${b.height}px`);const c=b.style;c!=null&&Object.keys(c).forEach(e=>{d[e]=c[e]})};var v=(()=>{let a=0;return()=>{a+=1;return`u${`0000${(Math.random()*1679616<<0).toString(36)}`.slice(-4)}${a}`}})();function w(a){const b=[];for(let d=0,c=a.length;d<c;d++)b.push(a[d]);return b}let x=null;function y(a={}){return x?x:a.l?x=a.l:x=w(window.getComputedStyle(document.documentElement))}function z(a,b){return(a=(a.ownerDocument.defaultView||window).getComputedStyle(a).getPropertyValue(b))?parseFloat(a.replace("px","")):0}
function A(a,b={}){var d;if(!(d=b.width)){d=z(a,"border-left-width");var c=z(a,"border-right-width");d=a.clientWidth+d+c}(b=b.height)||(b=z(a,"border-top-width"),c=z(a,"border-bottom-width"),b=a.clientHeight+b+c);return{width:d,height:b}}function B(a){return new Promise((b,d)=>{const c=new Image;c.onload=()=>{c.decode().then(()=>{requestAnimationFrame(()=>b(c))})};c.onerror=d;c.crossOrigin="anonymous";c.decoding="async";c.src=a})}
function C(a){return t(function*(){return Promise.resolve().then(()=>(new XMLSerializer).serializeToString(a)).then(encodeURIComponent).then(b=>`data:image/svg+xml;charset=utf-8,${b}`)})}
function D(a,b,d){return t(function*(){const c=document.createElementNS("http://www.w3.org/2000/svg","svg"),e=document.createElementNS("http://www.w3.org/2000/svg","foreignObject");c.setAttribute("width",`${b}`);c.setAttribute("height",`${d}`);c.setAttribute("viewBox",`0 0 ${b} ${d}`);e.setAttribute("width","100%");e.setAttribute("height","100%");e.setAttribute("x","0");e.setAttribute("y","0");e.setAttribute("externalResourcesRequired","true");c.appendChild(e);e.appendChild(a);return C(c)})}
var E=(a,b)=>{if(a instanceof b)return!0;a=Object.getPrototypeOf(a);return a===null?!1:a.constructor.name===b.name||E(a,b)};function F(a,b){return y(b).map(d=>{const c=a.getPropertyValue(d),e=a.getPropertyPriority(d);return`${d}: ${c}${e?" !important":""};`}).join(" ")}
function G(a,b,d,c){a=window.getComputedStyle(a,d);var e=a.getPropertyValue("content");if(e!==""&&e!=="none"){var f=v();try{b.className=`${b.className} ${f}`}catch(k){return}e=document.createElement("style");var g=e.appendChild;d=`.${f}:${d}`;a.cssText?(c=a.getPropertyValue("content"),c=`${a.cssText} content: '${c.replace(/'|"/g,"")}';`):c=F(a,c);g.call(e,document.createTextNode(`${d}{${c}}`));b.appendChild(e)}};function H(a){return a.search(/^(data:)/)!==-1}function I(a,b,d){return t(function*(){const c=yield fetch(a,b);if(c.status===404)throw Error(`Resource "${c.url}" not found`);const e=yield c.blob();return new Promise((f,g)=>{const k=new FileReader;k.onerror=g;k.onloadend=()=>{try{f(d({o:c,result:k.result}))}catch(m){g(m)}};k.readAsDataURL(e)})})}const J={};function K(a,b,d){let c=a.replace(/\?.*/,"");d&&(c=a);/ttf|otf|eot|woff2?/i.test(c)&&(c=c.replace(/.*\//,""));return b?`[${b}]${c}`:c}
function L(a,b,d){return t(function*(){const c=K(a,b,d.C);if(J[c]!=null)return J[c];d.u&&(a+=(/\?/.test(a)?"&":"?")+(new Date).getTime());let e;try{const f=yield I(a,d.i,({o:g,result:k})=>{b||(b=g.headers.get("Content-Type")||"");return k.split(/,/)[1]});e=`data:${b};base64,${f}`}catch(f){e=d.B||""}return J[c]=e})};const M={P:"application/font-woff",R:"application/font-woff",N:"application/font-truetype",v:"application/vnd.ms-fontobject",H:"image/png",F:"image/jpeg",D:"image/jpeg",A:"image/gif",M:"image/tiff",L:"image/svg+xml",O:"image/webp"};function N(a){return(a=/\.([^./]*?)$/g.exec(a))?a[1]:""};function O(a){return t(function*(){const b=a.toDataURL();return b==="data:,"?a.cloneNode(!1):B(b)})}function aa(a,b){return t(function*(){if(a.currentSrc){var d=document.createElement("canvas");const c=d.getContext("2d");d.width=a.clientWidth;d.height=a.clientHeight;c==null||c.drawImage(a,0,0,d.width,d.height);d=d.toDataURL();return B(d)}d=a.poster;d=yield L(d,M[N(d).toLowerCase()]||"",b);return B(d)})}
function ba(a,b){return t(function*(){try{let d;if(a==null?0:(d=a.contentDocument)==null?0:d.body)return yield P(a.contentDocument.body,b,!0)}catch(d){}return a.cloneNode(!1)})}function ca(a,b){return t(function*(){return E(a,HTMLCanvasElement)?O(a):E(a,HTMLVideoElement)?aa(a,b):E(a,HTMLIFrameElement)?ba(a,b):a.cloneNode(a.tagName!=null&&a.tagName.toUpperCase()==="SVG")})}
function da(a,b,d){return t(function*(){if(b.tagName!=null&&b.tagName.toUpperCase()==="SVG")return b;let c=[];if(a.tagName!=null&&a.tagName.toUpperCase()==="SLOT"&&a.assignedNodes)c=w(a.assignedNodes());else{let e;if(E(a,HTMLIFrameElement)&&((e=a.contentDocument)==null?0:e.body))c=w(a.contentDocument.body.childNodes);else{let f;c=w(((f=a.shadowRoot)!=null?f:a).childNodes)}}if(c.length===0||E(a,HTMLVideoElement))return b;yield c.reduce((e,f)=>e.then(()=>P(f,d)).then(g=>{g&&b.appendChild(g)}),Promise.resolve());
return b})}function ea(a,b,d){const c=b.style;if(c){var e=window.getComputedStyle(a);e.cssText?(c.cssText=e.cssText,c.transformOrigin=e.transformOrigin):y(d).forEach(f=>{let g=e.getPropertyValue(f);f==="font-size"&&g.endsWith("px")&&(g=`${Math.floor(parseFloat(g.substring(0,g.length-2)))-.1}px`);E(a,HTMLIFrameElement)&&f==="display"&&g==="inline"&&(g="block");f==="d"&&b.getAttribute("d")&&(g=`path(${b.getAttribute("d")})`);c.setProperty(f,g,e.getPropertyPriority(f))})}}
function fa(a,b){E(a,HTMLSelectElement)&&(b=Array.from(b.children).find(d=>a.value===d.getAttribute("value")))&&b.setAttribute("selected","")}
function ha(a,b){return t(function*(){var d=a.querySelectorAll?a.querySelectorAll("use"):[];if(d.length===0)return a;var c={};for(var e=0;e<d.length;e++){var f=d[e].getAttribute("xlink:href");if(f){const g=document.querySelector(f);a.querySelector(f)||!g||c[f]||(c[f]=yield P(g,b,!0))}}d=Object.values(c);if(d.length){c=document.createElementNS("http://www.w3.org/1999/xhtml","svg");c.setAttribute("xmlns","http://www.w3.org/1999/xhtml");c.style.position="absolute";c.style.width="0";c.style.height="0";
c.style.overflow="hidden";c.style.display="none";e=document.createElementNS("http://www.w3.org/1999/xhtml","defs");c.appendChild(e);for(f=0;f<d.length;f++)e.appendChild(d[f]);a.appendChild(c)}return a})}
function P(a,b,d){return t(function*(){return d||!b.filter||b.filter(a)?Promise.resolve(a).then(c=>ca(c,b)).then(c=>da(a,c,b)).then(c=>{E(c,Element)&&(ea(a,c,b),G(a,c,":before",b),G(a,c,":after",b),E(a,HTMLTextAreaElement)&&(c.textContent=a.value),E(a,HTMLInputElement)&&c.setAttribute("value",a.value),fa(a,c));return c}).then(c=>ha(c,b)):null})};const Q=/url\((['"]?)([^'"]+?)\1\)/g,ia=/url\([^)]+\)\s*format\((["']?)([^"']+)\1\)/g,ja=/src:\s*(?:url\([^)]+\)\s*format\([^)]+\)[,;]\s*)+/g;function ka(a){const b=[];a.replace(Q,(d,c,e)=>{b.push(e);return d});return b.filter(d=>!H(d))}
function la(a,b,d,c){return t(function*(){try{const e=d?(new URL(b,d||void 0)).toString():b;let f;f=yield L(e,M[N(b).toLowerCase()]||"",c);return a.replace(new RegExp(`(url\\(['"]?)(${b.replace(/([.*+?^${}()|\[\]\/\\])/g,"\\$1")})(['"]?\\))`,"g"),`$1${f}$3`)}catch(e){}return a})}function ma(a,{I:b}){return b?a.replace(ja,d=>{for(;;){const [c,,e]=ia.exec(d)||[],f=c,g=e;if(!g)return"";if(g===b)return`src: ${f};`}}):a}
function R(a,b,d){return t(function*(){if(a.search(Q)===-1)return a;const c=ma(a,d);return ka(c).reduce((e,f)=>e.then(g=>la(g,f,b,d)),Promise.resolve(c))})};function S(a,b,d){return t(function*(){var c;const e=(c=b.style)==null?void 0:c.getPropertyValue(a);return e?(c=yield R(e,null,d),b.style.setProperty(a,c,b.style.getPropertyPriority(a)),!0):!1})}function na(a,b){return t(function*(){(yield S("background",a,b))||(yield S("background-image",a,b));(yield S("mask",a,b))||(yield S("-webkit-mask",a,b))||(yield S("mask-image",a,b))||(yield S("-webkit-mask-image",a,b))})}
function oa(a,b){return t(function*(){const d=E(a,HTMLImageElement);if(d&&!H(a.src)||E(a,SVGImageElement)&&!H(a.href.baseVal)){var c=d?a.src:a.href.baseVal,e=yield L(c,M[N(c).toLowerCase()]||"",b);yield new Promise((f,g)=>{a.onload=f;a.onerror=b.m?(...k)=>{try{f(b.m(...k))}catch(m){g(m)}}:g;a.decode&&(a.decode=f);a.loading==="lazy"&&(a.loading="eager");d?(a.srcset="",a.src=e):a.href.baseVal=e})}})}
function pa(a,b){return t(function*(){const d=w(a.childNodes).map(c=>T(c,b));yield Promise.all(d).then(()=>a)})}function T(a,b){return t(function*(){E(a,Element)&&(yield na(a,b),yield oa(a,b),yield pa(a,b))})};const U={};function V(a){return t(function*(){var b=U[a];if(b!=null)return b;b=yield(yield fetch(a)).text();b={url:a,cssText:b};return U[a]=b})}function W(a,b){return t(function*(){let d=a.cssText;const c=/url\(["']?([^"')]+)["']?\)/g,e=(d.match(/url\([^)]+\)/g)||[]).map(f=>t(function*(){let g=f.replace(c,"$1");g.startsWith("https://")||(g=(new URL(g,a.url)).href);return I(g,b.i,({result:k})=>{d=d.replace(f,`url(${k})`);return[f,k]})}));return Promise.all(e).then(()=>d)})}
function X(a){if(a==null)return[];const b=[];a=a.replace(/(\/\*[\s\S]*?\*\/)/gi,"");for(var d=RegExp("((@.*?keyframes [\\s\\S]*?){([\\s\\S]*?}\\s*?)})","gi");;){var c=d.exec(a);if(c===null)break;b.push(c[0])}a=a.replace(d,"");d=/@import[\s\S]*?url\([^)]*\)[\s\S]*?;/gi;for(c=RegExp("((\\s*?(?:\\/\\*[\\s\\S]*?\\*\\/)?\\s*?@media[\\s\\S]*?){([\\s\\S]*?)}\\s*?})|(([\\s\\S]*?){([\\s\\S]*?)})","gi");;){let e=d.exec(a);if(e===null)if(e=c.exec(a),e===null)break;else d.lastIndex=c.lastIndex;else c.lastIndex=
d.lastIndex;b.push(e[0])}return b}
function qa(a,b){return t(function*(){const d=[],c=[];a.forEach(e=>{if("cssRules"in e)try{w(e.cssRules||[]).forEach((f,g)=>{if(f.type===CSSRule.IMPORT_RULE){let k=g+1;f=V(f.href).then(m=>W(m,b)).then(m=>X(m).forEach(q=>{try{e.insertRule(q,q.startsWith("@import")?k+=1:e.cssRules.length)}catch(Da){}})).catch(()=>{});c.push(f)}})}catch(f){const g=a.find(k=>k.href==null)||document.styleSheets[0];e.href!=null&&c.push(V(e.href).then(k=>W(k,b)).then(k=>X(k).forEach(m=>{g.insertRule(m,g.cssRules.length)})).catch(()=>
{}))}});return Promise.all(c).then(()=>{a.forEach(e=>{if("cssRules"in e)try{w(e.cssRules||[]).forEach(f=>{d.push(f)})}catch(f){}});return d})})}function ra(a){return a.filter(b=>b.type===CSSRule.FONT_FACE_RULE).filter(b=>b.style.getPropertyValue("src").search(Q)!==-1)}function sa(a,b){return t(function*(){if(a.ownerDocument==null)throw Error("Provided element is not within a Document");var d=w(a.ownerDocument.styleSheets);d=yield qa(d,b);return ra(d)})}
function ta(a){function b(c){(c.style.fontFamily||getComputedStyle(c).fontFamily).split(",").forEach(e=>{d.add(e.trim().replace(/["']/g,""))});Array.from(c.children).forEach(e=>{e instanceof HTMLElement&&b(e)})}const d=new Set;b(a);return d}function ua(a,b){return t(function*(){const d=yield sa(a,b),c=ta(a);return(yield Promise.all(d.filter(e=>c.has(e.style.fontFamily.trim().replace(/["']/g,""))).map(e=>R(e.cssText,e.parentStyleSheet?e.parentStyleSheet.href:null,b)))).join("\n")})}
function va(a,b){return t(function*(){const d=b.j!=null?b.j:b.K?null:yield ua(a,b);if(d){const c=document.createElement("style");c.appendChild(document.createTextNode(d));a.firstChild?a.insertBefore(c,a.firstChild):a.appendChild(c)}})};function wa(a,b={}){return t(function*(){const {width:d,height:c}=A(a,b),e=yield P(a,b,!0);yield va(e,b);yield T(e,b);u(e,b);return yield D(e,d,c)})}
function xa(a,b={}){return t(function*(){const {width:d,height:c}=A(a,b);var e=yield wa(a,b);e=yield B(e);const f=document.createElement("canvas"),g=f.getContext("2d"),k=b.G||window.devicePixelRatio||1,m=b.h||d,q=b.g||c;f.width=m*k;f.height=q*k;!b.J&&(f.width>16384||f.height>16384)&&(f.width>16384&&f.height>16384?f.width>f.height?(f.height*=16384/f.width,f.width=16384):(f.width*=16384/f.height,f.height=16384):f.width>16384?(f.height*=16384/f.width,f.width=16384):(f.width*=16384/f.height,f.height=
16384));f.style.width=`${m}`;f.style.height=`${q}`;b.backgroundColor&&(g.fillStyle=b.backgroundColor,g.fillRect(0,0,f.width,f.height));g.drawImage(e,0,0,f.width,f.height);return f})}function ya(a,b={}){return t(function*(){return(yield xa(a,b)).toDataURL()})};const za=["gemini.google.com","corp.google.com","proxy.googlers.com"];function Y(){return document.body.querySelectorAll('[class*="animate"]').length>0}function Z(a){return t(function*(){try{return yield ya(a,{h:a.offsetWidth,g:a.offsetHeight})}catch(d){var b=a.offsetHeight;const c=document.createElement("canvas");c.width=a.offsetWidth;c.height=b;return c.toDataURL("image/png")}})}
function Aa(){return t(function*(){const a=document.body.offsetWidth,b=document.body.offsetHeight,d=document.body.cloneNode(!0);d.querySelectorAll('[class*="animate"]').forEach(c=>{c.classList.remove(...Array.from(c.classList).filter(e=>e.startsWith("animate")))});d.style.width=`${a}px`;d.style.height=`${b}px`;return d})}
function Ba(a){return t(function*(){let b=document.body;if(Y()){var d=yield Aa();b=d;document.body.appendChild(d)}d=yield Z(b);Y()&&document.body.removeChild(b);window.parent.postMessage({type:"SEND_SCREENSHOT",image:d,topOffset:document.documentElement.scrollTop},a.origin)})}function Ca(a){return t(function*(){const b={type:"SEND_SCREENSHOT_FOR_DATA_VISUALIZATION",image:yield Z(document.body),topOffset:0};window.parent.postMessage(b,a.origin)})}
window.addEventListener("message",a=>t(function*(){if(za.some(d=>a.origin.includes(d))){var b=a.data;b&&(b.type==="MAKE_SCREENSHOT"&&(yield Ba(a)),b.type==="MAKE_SCREENSHOT_FOR_DATA_VISUALIZATION"&&(yield Ca(a)))}}));
</script><script>(function() {
  // Ensure this script is executed only once
  if (window.firebaseAuthBridgeScriptLoaded) {
    return;
  }
  window.firebaseAuthBridgeScriptLoaded = true;

  let nextTokenPromiseId = 0;

  // Stores { resolve, reject } for ongoing token requests
  const pendingTokenPromises = {};

  // Listen for messages from the Host Application
  window.addEventListener('message', function(event) {

    const messageData = event.data;

  if (messageData && messageData.type === 'RESOLVE_NEW_FIREBASE_TOKEN') {
      const { success, token, error, promiseId } = messageData ?? {};
      if (pendingTokenPromises[promiseId]) {
        if (success) {
          pendingTokenPromises[promiseId].resolve(token);
        } else {
          pendingTokenPromises[promiseId].reject(new Error(error || 'Token refresh failed from host.'));
        }
        delete pendingTokenPromises[promiseId];
      }
    }
  });

  // Expose a function for the Generated App to request a new Firebase token
  window.requestNewFirebaseToken = function() {
    const currentPromiseId = nextTokenPromiseId++;
    const promise = new Promise((resolve, reject) => {
      pendingTokenPromises[currentPromiseId] = { resolve, reject };
    });
    if (window.parent && window.parent !== window) {
      window.parent.postMessage({
        type: 'REQUEST_NEW_FIREBASE_TOKEN',
        promiseId: currentPromiseId
      }, '*');
    } else {
      pendingTokenPromises[currentPromiseId].reject(new Error('No parent window to request token from.'));
      delete pendingTokenPromises[currentPromiseId];
    }
    return promise;
  };
})();</script><script>
let realOriginalGetUserMedia = null;
if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
  realOriginalGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);
}

(function() {
  if (navigator.mediaDevices && navigator.mediaDevices.__proto__) {
    try {
      Object.defineProperty(navigator.mediaDevices.__proto__, 'getUserMedia', {
        get: function() {
          return undefined; // Or throw an error
        },
        configurable: false
      });
    } catch (error) {
      console.error("Error defining prototype getter:", error);
    }
  }
})();

(function() {
  const pendingMediaResolvers = {};
  let nextMediaPromiseId = 0;

  function requestMediaPermissions(constraints) {
    const mediaPromiseId = nextMediaPromiseId++;
    const promise = new Promise((resolve, reject) => {
      pendingMediaResolvers[mediaPromiseId] = (granted) => {
        delete pendingMediaResolvers[mediaPromiseId];
        resolve(granted);
      };
    });

    window.parent.postMessage({
      type: 'requestMediaPermission',
      constraints: constraints,
      promiseId: mediaPromiseId,
    }, '*');

    return promise;
  }

  let originalGetUserMedia = realOriginalGetUserMedia;

  function interceptGetUserMedia() {
    if (navigator.mediaDevices) {
      Object.defineProperty(navigator.mediaDevices, 'getUserMedia', {
        value: function(constraints) {
          return requestMediaPermissions(constraints).then((granted) => {
            if (granted) {
              if (originalGetUserMedia) {
                return originalGetUserMedia(constraints);
              } else {
                throw new Error("Original getUserMedia not available.");
              }
            } else {
              throw new DOMException('Permission denied', 'NotAllowedError');
            }
          });
        },
        writable: false,
        configurable: false
      });
    }
  }

  interceptGetUserMedia();

  const observer = new MutationObserver(function(mutationsList, observer) {
    for (const mutation of mutationsList) {
      if (mutation.type === 'reconfigured' && mutation.name === 'getUserMedia' && mutation.object === navigator.mediaDevices) {
        interceptGetUserMedia();
      } else if (mutation.type === 'attributes' && mutation.attributeName === 'getUserMedia' && mutation.target === navigator.mediaDevices) {
        interceptGetUserMedia();
      } else if (mutation.type === 'childList' && mutation.addedNodes) {
        mutation.addedNodes.forEach(node => {
          if (node === navigator.mediaDevices) {
            interceptGetUserMedia();
          }
        });
      }
    }
  });

  function interceptSpeechRecognition() {
    if (!window.SpeechRecognition && !window.webkitSpeechRecognition) {
      return;
    }

    const OriginalSpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

    const SpeechRecognitionWrapper = function(...args) {
      const recognizer = new OriginalSpeechRecognition(...args);
      const originalStart = recognizer.start.bind(recognizer);

      recognizer.start = function() {
        requestMediaPermissions({ audio: true }).then(granted => {
          if (granted) {
            originalStart();
          } else {
            const errorEvent = new SpeechRecognitionErrorEvent('error');
            errorEvent.error = 'not-allowed'; // This is the standard error for permission denial.
            recognizer.dispatchEvent(errorEvent);
          }
        });
      };

      return recognizer;
    };

    SpeechRecognitionWrapper.prototype = OriginalSpeechRecognition.prototype;
    SpeechRecognitionWrapper.prototype.constructor = SpeechRecognitionWrapper;

    if (window.SpeechRecognition) {
      window.SpeechRecognition = SpeechRecognitionWrapper;
    }
    if (window.webkitSpeechRecognition) {
      window.webkitSpeechRecognition = SpeechRecognitionWrapper;
    }
  }

  interceptSpeechRecognition();

  window.addEventListener('message', function(event) {
    if (event.data) {
      if (event.data.type === 'resolveMediaPermission') {
        const { promiseId, granted } = event.data;
        if (pendingMediaResolvers[promiseId]) {
          pendingMediaResolvers[promiseId](granted);
        }
      }
    }
  });

})();</script><script>((function(modelInformation) {
  const originalFetch = window.fetch;
  // TODO: b/421908508 - Move these out of the script and match all generative AI model calls.
  let googleLlmBaseApiUrls = [
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.textModelName + ':streamGenerateContent',
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.textModelName + ':generateContent',
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.imageModelName + ':predict',
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.imageModelName + ':predictLongRunning',
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.imageEditModelName + ':generateContent',
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.imageTransformModelName + ':generateContent',
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.videoModelName + ':predict',
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.videoModelName + ':predictLongRunning',
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.ttsModelName + ':generateContent',
  ];
  modelInformation.deprecatedTextModelNames.forEach((modelName) => {
    googleLlmBaseApiUrls.push(
      'https://generativelanguage.googleapis.com/v1beta/models/' + modelName + ':streamGenerateContent',
      'https://generativelanguage.googleapis.com/v1beta/models/' + modelName + ':generateContent',
    );
  });
  modelInformation.deprecatedImageModelNames.forEach((modelName) => {
    googleLlmBaseApiUrls.push(
      'https://generativelanguage.googleapis.com/v1beta/models/' + modelName + ':predict',
      'https://generativelanguage.googleapis.com/v1beta/models/' + modelName + ':predictLongRunning',
    );
  });

  const pendingFetchResolvers = {};
  let nextPromiseId = 0;

  function handleStringInput(input, optionsArgument) {
    const actualUrl = input;
    const fetchCallArgs = [actualUrl, optionsArgument];
    const effectiveOptions = optionsArgument || {};
    const bodyForApiKeyCheck = effectiveOptions.body;
    const bodyForPostMessage = effectiveOptions.body;
    return { actualUrl, fetchCallArgs, effectiveOptions, bodyForApiKeyCheck, bodyForPostMessage };
  }

  function handleRequestInput(input, optionsArgument) {
    const actualUrl = input.url;
    const fetchCallArgs = [input, optionsArgument];
    const effectiveOptions = { method: input.method, headers: new Headers(input.headers) };
    let bodyForApiKeyCheck;
    let bodyForPostMessage;

    if (optionsArgument) {
      if (optionsArgument.method) effectiveOptions.method = optionsArgument.method;
      if (optionsArgument.headers) effectiveOptions.headers = new Headers(optionsArgument.headers);
      if ('body' in optionsArgument) {
        bodyForApiKeyCheck = optionsArgument.body;
        bodyForPostMessage = optionsArgument.body;
      } else {
        bodyForApiKeyCheck = undefined;
        bodyForPostMessage = input.body;
      }
    } else {
      bodyForApiKeyCheck = undefined;
      bodyForPostMessage = input.body;
    }
    return { actualUrl, fetchCallArgs, effectiveOptions, bodyForApiKeyCheck, bodyForPostMessage };
  }

  window.fetch = function(input, optionsArgument) {
    let actualUrl;
    let fetchCallArgs;
    let effectiveOptions = {};
    let bodyForApiKeyCheck;
    let bodyForPostMessage;

    if (typeof input === 'string') {
      ({actualUrl, fetchCallArgs, effectiveOptions, bodyForApiKeyCheck, bodyForPostMessage} = handleStringInput(input, optionsArgument));
    } else if (input instanceof Request) {
      ({actualUrl, fetchCallArgs, effectiveOptions, bodyForApiKeyCheck, bodyForPostMessage} = handleRequestInput(input, optionsArgument));
    } else {
      return originalFetch.apply(window, [input, optionsArgument]);
    }

    effectiveOptions.method = effectiveOptions.method || 'GET';
    if (!effectiveOptions.headers) {
      effectiveOptions.headers = new Headers();
    }


    if (typeof actualUrl === 'string' && googleLlmBaseApiUrls.some((url) => actualUrl.startsWith(url))) {
      let apiKeyIsNull = true;

      const regex = new RegExp("models/([^:]+)");
      const modelNameMatch = actualUrl.match(regex);
      const modelName = modelNameMatch ? modelNameMatch[1] : 'unspecified';


      try {
        const urlObject = new URL(actualUrl);  // Use URL object for robust parsing
        const apiKeyParam = urlObject.searchParams.get('key');
        if (apiKeyParam) {
          apiKeyIsNull = false;
        }
      } catch (e) {
        // Continue checks even if URL parsing fails
      }

      if (apiKeyIsNull && effectiveOptions.headers) {
        const h = new Headers(effectiveOptions.headers);
        const apiKeyHeaderValue = h.get('X-API-Key') || h.get('x-api-key');
        if (apiKeyHeaderValue) {
          apiKeyIsNull = false;
          return originalFetch.apply(window, fetchCallArgs);
        }
      }

      if (apiKeyIsNull && effectiveOptions.method && ['POST', 'PUT', 'PATCH'].includes(effectiveOptions.method.toUpperCase()) && typeof bodyForApiKeyCheck === 'string') {
        try {
          const bodyData = JSON.parse(bodyForApiKeyCheck);
          if (bodyData && bodyData.apiKey) {
            apiKeyIsNull = false;
            return originalFetch.apply(window, fetchCallArgs);
          }
        } catch (e) {
          // Ignore JSON parsing errors
        }
      }

      if(apiKeyIsNull) {
        const promiseId = nextPromiseId++;
        const promise = new Promise((resolve) => {
          pendingFetchResolvers[promiseId] = (resolvedResponse) => {
            delete pendingFetchResolvers[promiseId];
            resolve(resolvedResponse);
          };
        });

        let serializedBodyForPostMessage;
        if (typeof bodyForPostMessage === 'string' || bodyForPostMessage == null) {
            serializedBodyForPostMessage = bodyForPostMessage;
        } else if (bodyForPostMessage instanceof ReadableStream) {
            serializedBodyForPostMessage = null;
        } else {
            try {
                serializedBodyForPostMessage = JSON.stringify(bodyForPostMessage);
            } catch (e) {
                serializedBodyForPostMessage = null;
            }
        }

        const messageOptions = {
            method: effectiveOptions.method,
            headers: Object.fromEntries(new Headers(effectiveOptions.headers).entries()),
            body: serializedBodyForPostMessage
        };

        window.parent.postMessage({
          type: 'requestFetch',
          url: actualUrl,
          modelName: modelName,
          options: messageOptions,
          promiseId: promiseId,
        }, '*');

        return promise;
      }
      return originalFetch.apply(window, fetchCallArgs);
    }
    return originalFetch.apply(window, fetchCallArgs);
  };

  window.addEventListener('message', function(event) {
    if (event.data && event.data.type === 'resolveFetch') {
      const { promiseId, response } = event.data;
      if (pendingFetchResolvers[promiseId]) {
        try {
          const reconstructedResponse = new Response(response.body, {
            status: response.status,
            statusText: response.statusText,
            headers: new Headers(response.headers),
          });
          pendingFetchResolvers[promiseId](reconstructedResponse);
        } catch (error) {
          pendingFetchResolvers[promiseId](new Response(null, { status: 500, statusText: "Interceptor Response Reconstruction Error" }));
        }
      }
    }
  });

}))({"textModelName":"gemini-2.5-flash-preview-09-2025","imageModelName":"imagen-4.0-generate-001","imageEditModelName":"gemini-2.5-flash-image-preview","imageTransformModelName":"gemini-3-pro-image-preview-11-2025","videoModelName":"veo-2.0-generate-001","ttsModelName":"gemini-2.5-flash-preview-tts","deprecatedTextModelNames":["gemini-2.0-flash","gemini-2.5-flash-preview-04-17","gemini-2.5-flash-preview-05-20"],"deprecatedImageModelNames":["imagen-3.0-generate-001","imagen-3.0-generate-002"]})</script><script>(function() {
  const originalConsoleLog = console.log;
  const originalConsoleError = console.error;

    /**
   * Normalizes an error event or a promise rejection reason into a structured error object.
   * @param {*} errorEventOrReason The error object or reason.
   * @return {object} Structured error data { message, name, stack }.
   */
  function getErrorObject(errorEventOrReason) {
    if (errorEventOrReason instanceof Error) {
      return {
        message: errorEventOrReason.message,
        name: errorEventOrReason.name,
        stack: errorEventOrReason.stack,
      };
    }
    // Fallback for non-Error objects.
    try {
      return {
        message: JSON.stringify(errorEventOrReason),
        name: 'UnknownErrorType',
        stack: null,
      };
    } catch (e) {
      return {
        message: String(errorEventOrReason),
        name: 'UnknownErrorTypeNonStringifiable',
        stack: null,
      };
    }
  }

  /**
   * Converts an array of arguments (from log/error) into a single string.
   * Handles Error objects specially to include their message and stack.
   * @param {Array<*>} args - Arguments passed to console methods.
   * @return {string} A string representation of the arguments.
   */
  function stringifyArgs(args) {
    return args
      .map((arg) => {
        if (arg instanceof Error) {
          const {message, stack} = arg;
          return `Error: ${message}${stack ? ('\nStack: ' + stack) : ''}`;
        }
        if (typeof arg === 'object' && arg !== null) {
          try {
            return JSON.stringify(arg);
          } catch (error) {
            return '[Circular Object]';
          }
        } else {
          return String(arg);
        }
      })
      .join(' ');
  }

  console.log = function(...args) {
    const logString = stringifyArgs(args);
    window.parent.postMessage({ type: 'log', message: logString }, '*');
    originalConsoleLog.apply(console, args);
  };

  console.error = function(...args) {
    let errorData;
    if (args.length > 0 && args[0] instanceof Error) {
      const err = args[0];
      // If the first arg is an Error, capture its details.
      errorData = {
        type: 'error',
        source: 'CONSOLE_ERROR',
        ...getErrorObject(err),
        rawArgsString: stringifyArgs(args.slice(1)),
        timestamp: new Date().toISOString(),
      };
    } else {
      // If not an Error object, treat all args as a general error message.
      errorData = {
        type: 'error',
        source: 'CONSOLE_ERROR',
        message: stringifyArgs(args),
        name: 'ConsoleLoggedError',
        stack: null,
        timestamp: new Date().toISOString(),
      };
    }
    window.parent.postMessage(errorData, '*');
    originalConsoleError.apply(console, args);
  };

  // Listen for global unhandled synchronous errors.
  window.addEventListener('error', function(event) {
    const errorDetails = event.error ? getErrorObject(event.error) : {
      message: event.message,
      name: 'GlobalError',
      stack: null,
      filename: event.filename,
      lineno: event.lineno,
      colno: event.colno,
    };

    window.parent.postMessage({
      type: 'error',
      source: 'global',
      ...errorDetails,
      message: errorDetails.message || event.message,
      timestamp: new Date().toISOString(),
    }, '*');
  });

  // Listen for unhandled promise rejections (asynchronous errors).
  window.addEventListener('unhandledrejection', function(event) {
    const errorDetails = getErrorObject(event.reason);

    window.parent.postMessage({
      type: 'error',
      source: 'unhandledrejection',
      ...errorDetails,
      message: errorDetails.message || 'Unhandled Promise Rejection',
      timestamp: new Date().toISOString(),
    }, '*');
  });

})();</script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Widget Shell</title>
<!-- 1. External Libraries -->    <link href="https://fonts.googleapis.com/css2?family=Material+Icons" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Google+Sans:wght@400;500;700&amp;family=Roboto:wght@400;500;700&amp;display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/12.4.0/math.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3@7.9.0" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@observablehq/plot@0.6.16" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/build/three.min.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/controls/OrbitControls.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.2/lib/anime.min.js" crossorigin="anonymous"></script>

<!-- 2. CSS Design System -->    <style>
/* --- 1. TOKEN DEFINITIONS --- */      :root {
--on-surface-default: #0A0A0A; --on-surface-de-emphasis: #56595E; --on-surface-primary: #1558D6;
        --on-primary: #FFFFFF; --surface: #FFFFFF; --surface-container: #F0F2F5; --surface-container-high: #E9EBF0;
        --surface-container-lowest: var(--surface); --surface-container-low: var(--surface-container); --surface-container-highest: var(--surface-container-high);
        --outline: var(--stroke-default); --outline-variant: var(--stroke-emphasis);
        --primary: #0B50D0; --primary-hover: #0A45B4; --highlight: #D3E3FD;
        --stroke-default: #DCDFE5; --stroke-emphasis: #80858C;
        --positive: #046E00; --positive-surface: #C8E6C9; --negative: #C0151D; --negative-surface: #FFCDD2;
        --blue: #1558D6; --green: #046E00; --yellow: #EAA937; --red: #C0151D; --purple: #681DA8; --orange: #D85900;
        --chart-1: var(--blue); --chart-2: var(--green); --chart-3: var(--yellow); --chart-4: var(--red); --chart-5: var(--purple);
        --tertiary: var(--chart-3);
        --on-tertiary: var(--surface);        --ff-sans: "Google Sans", "Roboto", sans-serif;
        --fs-100: 0.75rem; --fs-200: 0.875rem; --fs-300: 1rem; --fs-400: 1.125rem; --fs-500: 1.25rem; --fs-600: 1.5rem;
        --fw-regular: 400; --fw-medium: 500; --fw-bold: 700;
        --space-xs: 0.5rem; --space-s: 0.75rem; --space-m: 1rem; --space-l: 1.5rem;
        --radius-sm: 4px; --radius-md: 8px; --radius-full: 999px;
      }

/* --- 2. RESET & BASE --- */      *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
      html, body { height: 100%; overflow: hidden; font-family: var(--ff-sans); font-size: var(--fs-300); line-height: 1.5; background: transparent; color: var(--on-surface-default); }
      h1, h2, h3 { font-weight: var(--fw-medium); margin-bottom: var(--space-s); line-height: 1.25; }
      h1 { font-size: var(--fs-600); } h2 { font-size: var(--fs-500); } h3 { font-size: var(--fs-400); }

/* --- 3. LAYOUT HELPERS --- */      .widget-container { background: var(--surface); height: 100%; display: flex; flex-direction: column; overflow: hidden; }
      .viz-container { 
        position: relative; 
        overflow: hidden; 
        flex: 1 1 0;
        min-height: 200px;
        display: flex;
        flex-direction: column;
        padding: 0 16px; 
      }
      .flex { display: flex; }
      .flex-col { display: flex; flex-direction: column; }
      .flex-row { display: flex; flex-direction: row; }
      .flex-wrap { flex-wrap: wrap; }
      .grow { flex-grow: 1; }
      .shrink-0 { flex-shrink: 0; }
      .items-center { align-items: center; } .justify-between { justify-content: space-between; } .justify-center { justify-content: center; }
      .gap-s { gap: var(--space-s); } .gap-m { gap: var(--space-m); } .gap-xs { gap: 0.25rem; } .gap-xxs { gap: 0.125rem; }
      .p-s { padding: var(--space-s); } .p-m { padding: var(--space-m); } .px-m { padding-left: var(--space-m); padding-right: var(--space-m); } .py-s { padding-top: var(--space-s); padding-bottom: var(--space-s); }
      .m-m { margin: var(--space-m); } .mt-m { margin-top: var(--space-m); }
      .border-t { border-top: 1px solid var(--stroke-default); } .rounded-md { border-radius: var(--radius-md); }
      .bg-surface { background-color: var(--surface); } .bg-surface-container { background-color: var(--surface-container); }
      .relative { position: relative; } .w-full, .w-100 { width: 100%; } .h-full, .h-100 { height: 100%; }
      .hidden { display: none !important; }

/* --- XXS WIDGET SYSTEM (Scientific Blue) --- */
:root { 
     --xxs-h: 32px; 
     --xxs-radius-pill: 999px; 
    --xxs-radius-active: 6px; /* Tighter radius for the morph effect */
 }

/* 1. Layout Engine */
.control-grid {
    display: flex !important; flex-wrap: wrap; gap: 12px;
    align-content: flex-start; padding-bottom: 24px; width: 100%;
    padding-top: 12px; /* Slight breathing room from the viz */
    
    /* SCROLLING BEHAVIOR RESTORED */
    max-height: 40vh;       /* Limit to 40% of viewport height */
    overflow-y: auto;       /* Scroll if content exceeds limit */
    overscroll-behavior: contain; /* Prevent scrolling the parent page */
    
    /* Visual Polish for Scroll container */
    border-top: 1px solid var(--outline);
    background: var(--surface); /* Ensure contrast against scroll content */
    z-index: 10;
}

/* Thin Scrollbar for Controls */
.control-grid::-webkit-scrollbar { width: 6px; }
.control-grid::-webkit-scrollbar-track { background: transparent; }
.control-grid::-webkit-scrollbar-thumb { 
    background-color: var(--outline); 
    border-radius: 4px; 
}
.control-grid::-webkit-scrollbar-thumb:hover { background-color: var(--on-surface-de-emphasis); }

.xxs-row { display: grid; align-items: center; gap: 8px; min-width: 0; }
.xxs-row.full { flex: 1 1 100%; }
.xxs-row.standard { grid-template-columns: 110px 1fr 52px; } /* Slightly wider label/value */
.xxs-row.compact { flex: 1 1 45%; min-width: 240px; }
.xxs-row.compact.input { grid-template-columns: 1fr 120px; }
.xxs-row.header { flex: 1 1 100%; margin-top: 8px; grid-template-columns: 1fr; }
.xxs-label { 
    font-size: 12px; /* LEGIBILITY UPGRADE */
    font-weight: 500; 
    color: var(--on-surface-default); /* Higher contrast */
    opacity: 0.9;
    white-space: nowrap; overflow: hidden; text-overflow: ellipsis; 
}

/* NEW: Action Bar Layout */
.xxs-actions {
    flex: 1 1 100%;
    display: flex; gap: 8px; margin-top: 12px;
}
.xxs-actions .xxs-btn {
    flex: 1; /* Distribute width evenly */
    height: 32px; /* Slightly taller for easy tapping */
    font-size: 12px;
    display: inline-flex; align-items: center; justify-content: center;
    line-height: 1;
}

/* 2. Sliders & Pills */
.xxs-slider-wrap { width: 100%; height: var(--xxs-h); display: flex; align-items: center; position: relative; }
input[type=range].xxs-slider { -webkit-appearance: none; width: 100%; height: 100%; background: transparent; margin: 0; cursor: pointer; outline: none; z-index: 2; }
input[type=range].xxs-slider::-webkit-slider-runnable-track {
    width: 100%; height: 6px; border-radius: 3px; /* Revert to thick track */
    background: linear-gradient(to right, var(--primary) 0%, var(--primary) var(--progress, 0%), var(--outline) var(--progress, 0%), var(--outline) 100%);
    transition: background 0.1s;
}
input[type=range].xxs-slider::-webkit-slider-thumb {
    -webkit-appearance: none; height: 22px; width: 6px; /* Revert to thin pill */
    border-radius: var(--xxs-radius-pill); background: var(--primary); margin-top: -8px; 
    box-shadow: 0 0 0 2px var(--surface); transition: all 0.2s cubic-bezier(0.2, 1.2, 0.2, 1);
}
input[type=range].xxs-slider:active::-webkit-slider-thumb { width: 4px; height: 24px; margin-top: -9px; box-shadow: 0 0 0 3px var(--surface); }

.xxs-val-pill {
    width: 100%; height: 24px; 
    border: 1px solid transparent; 
    background: transparent; /* Cleaner look */
    border-radius: 6px; 
    font-family: var(--font-mono, monospace); 
    font-size: 12px; font-weight: 600; 
    text-align: center; 
    color: var(--primary); 
    /* Add subtle bottom border to look like an input */
    border-bottom: 1px solid var(--outline);
    outline: none; transition: 0.2s; -moz-appearance: textfield;
}
.xxs-val-pill:focus { border-bottom-color: var(--primary); background: var(--surface-container-high); }

/* TOGGLE SWITCHES */
.xxs-switch {
    width: 44px; height: 24px;
    background: var(--surface-container-high);
    border-radius: 999px;
    position: relative;
    cursor: pointer;
    transition: background 0.2s, box-shadow 0.2s;
    border: 1px solid var(--outline);
    flex-shrink: 0; /* Don't squash */
}
.xxs-switch:hover { border-color: var(--on-surface-de-emphasis); }

.xxs-switch .knob {
    width: 18px; height: 18px;
    background: var(--on-surface-de-emphasis); /* Off state knob color */
    border-radius: 50%;
    position: absolute;
    top: 2px; left: 2px;
    transition: transform 0.25s cubic-bezier(0.3, 1.3, 0.3, 1), background 0.2s;
    box-shadow: 0 1px 2px rgba(0,0,0,0.1);
}

.xxs-switch.active {
    background: var(--primary);
    border-color: var(--primary);
}

.xxs-switch.active .knob {
    background: var(--on-primary); /* On state knob color */
    transform: translateX(20px);
}

/* 3. Inputs & Buttons */
.xxs-input, .xxs-select {
    height: 28px; /* Fit inside 32px row */
    width: 100%; border: 1px solid var(--outline); background: var(--surface-container-low); 
    border-radius: 6px; padding: 0 8px; font-family: inherit; 
    font-size: 12px; color: var(--on-surface-default); outline: none;
}
.xxs-select { background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23777'%3e%3cpath d='M7 10l5 5 5-5z'/%3e%3c/svg%3e"); background-repeat: no-repeat; background-position: right 8px center; background-size: 20px; }
.xxs-input:focus, .xxs-select:focus { border-color: var(--primary); }

.xxs-section-title { font-size: 11px; font-weight: 700; text-transform: uppercase; color: var(--primary); border-bottom: 1px solid var(--outline); padding-bottom: 4px; width: 100%; }
.xxs-btn-group { display: flex; gap: 4px; width: 100%; }

/* EXPRESSIVE MORPH BUTTONS */
.xxs-btn { 
    flex: 1; height: 28px; 
    border: 1px solid var(--outline); 
    background: transparent; 
    color: var(--on-surface-default); /* Better contrast */
    font-size: 11px; font-weight: 600; 
    cursor: pointer; 
    
    /* The Morph */
    border-radius: 999px; 
    transition: border-radius 0.3s cubic-bezier(0.2, 0, 0, 1), background 0.2s, color 0.2s, border-color 0.2s; 
}
.xxs-btn:hover {
    background: var(--surface-container-high);
    border-radius: 6px; /* Morph to Rect */
}
.xxs-btn.selected { 
    background: var(--highlight); 
    color: var(--primary); 
    border-color: var(--primary);
    border-radius: 6px; /* Stay Rect */
}
.xxs-btn:active { transform: scale(0.96); border-radius: 6px; }
input[type="color"].xxs-color { padding: 0; border: none; height: 24px; width: 40px; cursor: pointer; background: none; }

/* --- 4. RESTORATION & POLISH --- */

/* A. Cool Glass Badges */
.viz-badges {
    position: absolute; top: 12px; left: 12px; /* Moved to left for better vis */
    display: flex; gap: 8px; pointer-events: none; z-index: 10;
}
.badge {
    background: rgba(255, 255, 255, 0.8); /* Glassy Light */
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    color: var(--primary);
    border: 1px solid rgba(255,255,255,0.5);
    box-shadow: 0 2px 8px rgba(0,0,0,0.05);
    
    padding: 6px 10px; border-radius: 20px;
    font-size: 11px; font-weight: 600; letter-spacing: 0.3px;
    display: flex; align-items: center; gap: 6px;
    transform-origin: top left; animation: badgePop 0.4s cubic-bezier(0.2, 1.5, 0.5, 1) forwards;
}
@media (prefers-color-scheme: dark) {
    .badge { background: rgba(30, 35, 45, 0.8); border-color: rgba(255,255,255,0.1); }
}
.badge .material-icons { font-size: 14px; }
@keyframes badgePop { from { opacity: 0; transform: scale(0.9) translateY(-5px); } to { opacity: 1; transform: scale(1) translateY(0); } }

/* B. Tech Status Bar */
#app-status {
    font-family: "SF Mono", "Roboto Mono", monospace;
    font-size: 11px; color: var(--on-surface-de-emphasis); /* Dark Grey Text */
    background: var(--surface-container-high); /* Light Grey Background */
    border: 1px solid var(--outline); /* Subtle border for definition */
    padding: 2px 8px; border-radius: 4px;
    opacity: 0.9;
}

/* C. Canvas Safety (Prevent Overlap/Squashing) */
.viz-container {
    min-height: 300px; /* Force enough room for physics/charts */
    border-bottom: 1px solid var(--outline); /* Visual separator from controls */
    z-index: 0;
}

/* A11Y: Expand Touch Targets without changing Visual Size */

/* 1. Buttons & Toggles */
.xxs-btn, .xxs-switch, .xxs-slider-wrap {
    position: relative; /* Anchor for pseudo-element */
}

/* Create invisible 44px+ hit zone centered on the 28px/24px element */
.xxs-btn::after, 
.xxs-switch::after {
    content: "";
    position: absolute;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    min-width: 44px; min-height: 44px;
    width: 100%; height: 100%; /* At least cover the element */
    z-index: 1;
    cursor: pointer;
}

/* 2. Sliders (Input Range) */
/* The input needs to be taller to capture touches, but visually centered */
input[type=range].xxs-slider {
    height: 44px; /* Physical height for touch */
    margin-top: -6px; /* Offset to visually center the track in the 32px container */
    position: relative;
    z-index: 2;
}
    </style>
    <script>
        if (window.d3) {
            const originalStyle = d3.selection.prototype.style;
            d3.selection.prototype.style = function(name, value, priority) {
                if (typeof name === 'object' && name !== null) {
                    for (const key in name) {
                        originalStyle.call(this, key, name[key]);
                    }
                    return this;
                }
                return originalStyle.call(this, name, value, priority);
            };
            
            const originalAttr = d3.selection.prototype.attr;
            d3.selection.prototype.attr = function(name, value) {
                if (typeof name === 'object' && name !== null) {
                    for (const key in name) {
                        originalAttr.call(this, key, name[key]);
                    }
                    return this;
                }
                return originalAttr.call(this, name, value);
            };
        }

        // FORCE PLOT STYLING
        if (window.Plot) {
            const originalPlot = Plot.plot;
            Plot.plot = (options) => {
                if (!options.style) options.style = {};
                // Enforce background/text colors for SVG text
                options.style.background = "transparent";
                options.style.color = "var(--on-surface-default)";
                
                // Inject default styles for tooltips if they exist
                if (options.marks) {
                    options.marks.forEach(m => {
                        // Plot uses 'tip' mark. We can inject default channels if missing.
                        // But simpler: just ensure the tip options use our colors
                        if (m.ariaLabel === "tip") {
                             if (!m.fill) m.fill = "var(--surface)";
                             if (!m.stroke) m.stroke = "var(--outline)";
                        }
                    });
                }
                return originalPlot(options);
            };
        }

        if (!window.WIDGET_INIT_DATA) window.WIDGET_INIT_DATA = null;

        window.addEventListener('message', (e) => {
            if (e.data?.type === 'set-theme') {
                document.documentElement.setAttribute('data-theme', e.data.theme);
                setTimeout(() => window.dispatchEvent(new CustomEvent('themeChanged')), 0);
            }
        });

        window.WH = window.WidgetHelpers = {
            lerp: (start, end, t) => start * (1 - t) + end * t,
            clamp: (num, min, max) => Math.min(Math.max(num, min), max),
            map: (value, low1, high1, low2, high2) => low2 + (high2 - low2) * (value - low1) / (high1 - low1),
            random: (min, max) => Math.random() * (max - min) + min,
            _el: (e) => (typeof e === 'string' ? document.getElementById(e.startsWith('#') ? e.slice(1) : e) : e),
            _getViz: (e) => {
                 let el = window.WH._el(e);
                 if (!el && typeof e === 'string') {
                     if (e === 'vizTop') el = document.getElementById('viz-top');
                     if (e === 'vizBottom') el = document.getElementById('viz-bottom');
                 }
                 
                 if (el && el.classList.contains('widget-container')) {
                     return el.querySelector('.viz-container') || el.querySelector('#viz') || el;
                 }
                // Fallback: If ID not found, default to main 'viz'
                if (!el && document.getElementById('viz')) return document.getElementById('viz');
                 return el;
            },

            normalizeData: (data) => {
                // Case 1: User passed a single object instead of array
                if (data && !Array.isArray(data) && typeof data === 'object') {
                    return [data];
                }
                // Case 2: User passed simple array of numbers [10, 20, 5] 
                // Plot expects objects often, or needs explicit x/y mapping.
                // We can auto-map simple arrays to objects: [{x:0, y:10}, {x:1, y:20}]
                if (Array.isArray(data) && data.length > 0 && typeof data[0] === 'number') {
                    return data.map((val, i) => ({ x: i, y: val, val: val }));
                }
                return data;
            },

            showError: (msg) => {
                /* console.error(msg); */
            },

            addBadge: (icon, text, isAuto = false) => {
                const ALLOWED_ICONS = ['touch_app', '3d_rotation', 'pan_tool', 'mouse', 'hand_gesture', 'zoom_in'];
                if (!ALLOWED_ICONS.includes(icon)) return;

                let c = document.getElementById('viz-badges');
                if (!c) {
                    const viz = document.querySelector('.viz-container');
                    if(viz) { c = document.createElement('div'); c.id='viz-badges'; c.className='viz-badges'; viz.appendChild(c); }
                }
                if (!c) return;

                if (!isAuto) {
                    c.setAttribute('data-user-modified', 'true');
                    const autoBadges = c.querySelectorAll('[data-auto="true"]');
                    autoBadges.forEach(b => b.remove());
                } else {
                    if (c.hasAttribute('data-user-modified')) return;
                }

                const existing = Array.from(c.children).find(b => b.innerHTML.includes(icon));
                if (existing) {
                    existing.innerHTML = '<span class="material-icons">' + icon + '</span> ' + text;
                    return;
                }

                const b = document.createElement('div');
                b.className = 'badge';
                if (isAuto) b.setAttribute('data-auto', 'true');
                b.innerHTML = '<span class="material-icons">' + icon + '</span> ' + text;
                c.appendChild(b);
            },

            createApp: (config) => {
                // Prevent duplicate calls gracefully
                if (window.WH._appCreated) { 
                    console.warn("WH.createApp called twice. Returning existing instance.");
                    return window.WH._activeAppAPI || {};
                }
                window.WH._appCreated = true;

                let state = config.state || {}; 
                const root = document.body;
                root.style.cssText = 'height:100%; display:flex; flex-direction:column; overflow:hidden; background:var(--surface); margin:0;';
                
                const header = document.createElement('div'); 
                header.className = 'widget-ui-part flex justify-between items-center px-m py-s border-b bg-surface shrink-0 flex-wrap gap-s'; 
                header.innerHTML = '<h3 class="text-sm fw-bold m-0" style="font-size:1rem;">' + (config.title || 'Widget') + '</h3><div id="app-status" class="caption font-mono"></div>'; 
                root.appendChild(header);
                const viz = document.createElement('div'); viz.id = 'viz'; viz.className = 'widget-ui-part viz-container grow bg-surface-container relative overflow-hidden'; const badges = document.createElement('div'); badges.id = 'viz-badges'; badges.className = 'viz-badges'; viz.appendChild(badges); root.appendChild(viz);
                const controls = document.createElement('div'); controls.id = 'controls-root'; controls.className = 'widget-ui-part p-m border-t bg-surface shrink-0 w-full control-grid'; root.appendChild(controls);

                const api = {
                    vizId: 'viz',
                    setStatus: (t) => { const el = document.getElementById('app-status'); if(el) el.textContent = t; },
                    _dedupe: (key) => { if(key) { const e = controls.querySelector('[data-key="' + key + '"]'); if(e) e.remove(); } },

                    // 1. SLIDER (Packed)
                    addSlider: (label, opts) => {
                        api._dedupe(opts.key);
                        const row = document.createElement('div'); 
                        row.className = 'xxs-row standard compact'; // FIXED: Compact packing
                        if (opts.key) row.setAttribute('data-key', opts.key);

                        // DEFENSIVE: Force floats
                        let min = parseFloat(opts.min ?? 0);
                        let max = parseFloat(opts.max ?? 100);
                        let step = parseFloat(opts.step ?? (max - min <= 10 ? 0.1 : 1));
                        let val = parseFloat(state[opts.key] ?? opts.value ?? (min + max)/2);
                        if (isNaN(val)) val = min;

                        const wrap = document.createElement('div'); wrap.className = 'xxs-slider-wrap';
                        const range = document.createElement('input'); range.type = 'range'; range.className = 'xxs-slider';
                        range.min = min; range.max = max; range.step = step; range.value = val;
                        wrap.appendChild(range);

                        const num = document.createElement('input'); num.type = 'number'; num.className = 'xxs-val-pill';
                        num.min = min; num.max = max; num.step = step; num.value = val;

                        const id = 'ctrl-' + Math.random().toString(36).substr(2, 5);
                        range.id = id;
                        const lbl = document.createElement('label'); 
                        lbl.className = 'xxs-label'; 
                        lbl.textContent = label;
                        lbl.htmlFor = id;
                        row.append(lbl, wrap, num); controls.appendChild(row);

                        const update = (v) => {
                            const n = parseFloat(v); range.value = n; num.value = n;
                            range.style.setProperty('--progress', ((n - min) / (max - min)) * 100 + '%');
                            if (opts.key && state[opts.key] !== n) state[opts.key] = n;
                        };
                        range.oninput = (e) => update(e.target.value); num.oninput = (e) => update(e.target.value);
                        update(val);
                        if(opts.key) window.addEventListener('widget-state-update', (e) => { if (e.detail.key === opts.key && e.detail.value != range.value) update(e.detail.value); });
                    },

                    addSelect: (label, options, opts) => {
                        api._dedupe(opts.key);
                        const row = document.createElement('div'); row.className = 'xxs-row compact input';
                        const sel = document.createElement('select'); sel.className = 'xxs-select';
                        
                        // 1. Capture options array safely
                        const safeOpts = (Array.isArray(options) ? options : options.options || []);

                        safeOpts.forEach(o => {
                            const val = typeof o === 'object' ? o.value : o, txt = typeof o === 'object' ? o.label : o;
                            const opt = document.createElement('option'); opt.value = val; opt.textContent = txt; sel.appendChild(opt);
                        });

                        sel.value = state[opts.key] != null ? state[opts.key] : (opts.value != null ? opts.value : sel.options[0]?.value);
                        
                        sel.onchange = (e) => { 
                            // DEFENSIVE: Lookup original value by index to preserve Type (String vs Number)
                            // This prevents "Monthly" -> NaN or "2024" -> 2024 auto-conversion bugs
                            const idx = e.target.selectedIndex;
                            let v;
                            if (idx >= 0 && idx < safeOpts.length) {
                                const o = safeOpts[idx];
                                v = typeof o === 'object' ? o.value : o;
                            } else {
                                v = e.target.value; // Fallback
                            }

                            if (opts.key) state[opts.key] = v; 
                        };
                        const id = 'ctrl-' + Math.random().toString(36).substr(2, 5);
                        sel.id = id;
                        const lbl = document.createElement('label');
                        lbl.className = 'xxs-label';
                        lbl.textContent = label;
                        lbl.htmlFor = id;
                        row.appendChild(lbl);
                        row.appendChild(sel); 
                        controls.appendChild(row);
                        if(opts.key) window.addEventListener('widget-state-update', (e) => { if (e.detail.key === opts.key) sel.value = e.detail.value; });
                    },

                    addToggle: (label, opts) => {
                        api._dedupe(opts.key);
                        const row = document.createElement('div'); row.className = 'xxs-row compact input';
                        
                        // 1. Create Switch Container
                        const switchEl = document.createElement('div');
                        switchEl.className = 'xxs-switch';
                        switchEl.setAttribute('role', 'switch');
                        switchEl.setAttribute('tabindex', '0'); // Make keyboard focusable
                        switchEl.innerHTML = '<div class="knob"></div>';
                        
                        // 2. State Logic
                        const isTrue = !!(state[opts.key] != null ? state[opts.key] : (opts.value != null ? opts.value : false));
                        
                        const updateUI = (val) => {
                            if (val) switchEl.classList.add('active');
                            else switchEl.classList.remove('active');
                            switchEl.setAttribute('aria-checked', val);
                        };
                        updateUI(isTrue);

                        // 3. Interaction
                        switchEl.onclick = () => {
                            const newVal = !switchEl.classList.contains('active');
                            updateUI(newVal);
                            if (opts.key) state[opts.key] = newVal;
                        };
                        switchEl.onkeydown = (e) => {
                            if (e.key === 'Enter' || e.key === ' ') {
                                e.preventDefault();
                                switchEl.click();
                            }
                        };

                        // 4. Assemble
                        // We use flex-grow on the label to push the switch to the right
                        const lbl = document.createElement('div');
                        lbl.className = 'xxs-label';
                        lbl.textContent = label;
                        lbl.style.flexGrow = '1';

                        row.appendChild(lbl);
                        row.appendChild(switchEl);
                        controls.appendChild(row);

                        if(opts.key) window.addEventListener('widget-state-update', (e) => { if (e.detail.key === opts.key) updateUI(!!e.detail.value); });
                    },

                    addInput: (label, value, type, onChange) => {
                        const row = document.createElement('div'); row.className = 'xxs-row compact input';
                        const input = document.createElement('input'); input.type = type; input.value = value;
                        input.className = type === 'color' ? 'xxs-color' : 'xxs-input';
                        input.oninput = (e) => onChange(e.target.value);
                        const id = 'ctrl-' + Math.random().toString(36).substr(2, 5);
                        input.id = id;
                        const lbl = document.createElement('label');
                        lbl.className = 'xxs-label';
                        lbl.textContent = label;
                        lbl.htmlFor = id;
                        row.appendChild(lbl);
                        row.appendChild(input); 
                        controls.appendChild(row);
                    },

                    addSegmentedControl: (label, options, opts) => {
                        api._dedupe(opts.key);
                        const row = document.createElement('div'); row.className = 'xxs-row compact input';
                        const group = document.createElement('div'); group.className = 'xxs-btn-group';
                        const optsData = Array.isArray(options) ? options : (options.options || []);
                        const buttons = [];
                        let currentVal = state[opts.key] != null ? state[opts.key] : (typeof optsData[0] === 'object' ? optsData[0].value : optsData[0]);
                        const syncUI = (val) => {
                            buttons.forEach(({btn, v}) => {
                                if (v == val) btn.classList.add('selected'); else btn.classList.remove('selected');
                            });
                        };
                        optsData.forEach(o => {
                            const val = typeof o === 'object' ? o.value : o, txt = typeof o === 'object' ? o.label : o;
                            const btn = document.createElement('button');
                            btn.className = 'xxs-btn'; btn.textContent = txt;
                            btn.onclick = () => { syncUI(val); if (opts.key) state[opts.key] = val; };
                            buttons.push({btn, v: val}); group.appendChild(btn);
                        });
                        syncUI(currentVal);
                        row.innerHTML = '<div class="xxs-label">' + label + '</div>'; row.appendChild(group); controls.appendChild(row);
                        if(opts.key) window.addEventListener('widget-state-update', (e) => { if (e.detail.key === opts.key) syncUI(e.detail.value); });
                    },

                    addSection: (title) => {
                        const row = document.createElement('div'); row.className = 'xxs-row header';
                        row.innerHTML = '<div class="xxs-section-title">' + title + '</div>'; controls.appendChild(row);
                    },
                    // 7. ACTION BUTTON (Smart Packing)
                    addButton: (label, onClick, variant) => {
                        // 1. Check if the LAST element is a "Button Cell" that has room (limit 2)
                        let targetRow = controls.lastElementChild;
                        const isButtonCell = targetRow && targetRow.classList.contains('xxs-button-cell');
                        
                        if (isButtonCell && targetRow.children.length < 2) {
                            // Pack into existing cell
                        } else {
                            // Create new cell
                            targetRow = document.createElement('div');
                            targetRow.className = 'xxs-row compact xxs-button-cell'; 
                            targetRow.style.display = 'flex'; // Override grid
                            targetRow.style.gap = '8px';
                            controls.appendChild(targetRow);
                        }

                        const btn = document.createElement('button');
                        // Default to neutral (secondary) unless explicitly primary
                        const isPrimary = variant === 'primary';
                        btn.className = 'xxs-btn ' + (isPrimary ? 'selected' : ''); 
                        btn.textContent = label;
                        btn.onclick = onClick;
                        
                        // Layout: Share space equally
                        btn.style.width = '100%';
                        btn.style.flex = '1'; 
                        
                        targetRow.appendChild(btn);
                    },
                    addAction: (label, onClick) => api.addButton(label, onClick),
                    
                    // DEFENSIVE: Polyfill addButtonGroup for hallucinations
                    addButtonGroup: (btns) => {
                        if (Array.isArray(btns)) {
                            btns.forEach(b => {
                                // Map common hallucinations to 'label'
                                const label = b.label || b.text || b.name || b.caption || "Button";
                                const action = b.action || b.onClick || b.callback || (() => {});
                                api.addButton(label, action, b.variant);
                            });
                        }
                    },

                    updateButton: (label, newLabel) => {
                        const btns = Array.from(controls.querySelectorAll('button'));
                        const b = btns.find(x => x.textContent === label);
                        if(b) b.textContent = newLabel;
                    },
                    updateSlider: (label, val) => {
                        const labels = Array.from(controls.querySelectorAll('.xxs-label'));
                        const lbl = labels.find(x => x.textContent === label);
                        if(lbl) {
                            const row = lbl.closest('.xxs-row');
                            const inp = row.querySelector('input[type=range]');
                            if(inp) { inp.value = val; inp.dispatchEvent(new Event('input')); }
                        }
                    },
                    splitViz: (fraction = 0.5) => {
                        const viz = document.getElementById('viz');
                        viz.innerHTML = ''; viz.style.display = 'flex'; viz.style.flexDirection = 'column';
                        let size = typeof fraction === 'number' ? (fraction * 100) + '%' : fraction;
                        const top = document.createElement('div'); top.id = 'viz-top'; top.className = 'relative overflow-hidden'; top.style.height = size; top.style.flexShrink = '0';
                        const bottom = document.createElement('div'); bottom.id = 'viz-bottom'; bottom.className = 'grow relative overflow-hidden border-t bg-surface'; 
                        viz.appendChild(top); viz.appendChild(bottom);
                        const badges = document.createElement('div'); badges.id = 'viz-badges'; badges.className = 'viz-badges'; top.appendChild(badges);
                        return { vizTop: 'viz-top', vizBottom: 'viz-bottom' };
                    }
                };

                if (config.params) {
                   const initialState = {};
                   Object.entries(config.params).forEach(([k, v]) => initialState[k] = (typeof v === 'object' && v !== null && 'value' in v) ? v.value : v);
                   state = window.WH.createState(initialState);
                   
                   Object.entries(config.params).forEach(([key, conf]) => {
                       const label = conf.label || key.charAt(0).toUpperCase() + key.slice(1).replace(/([A-Z])/g, ' $1').trim();
                       const opts = { key, ...conf };
                       if (conf.type === 'header') api.addSection(label);
                       else if (conf.type === 'segmented') api.addSegmentedControl(label, conf.options, opts);
                       else if (['color','text','date'].includes(conf.type)) api.addInput(label, conf.value, conf.type, (v) => { if(state) state[key] = v; });
                       else if (conf.options) api.addSelect(label, conf.options, opts);
                       else if (typeof conf.value === 'boolean') api.addToggle(label, opts);
                       else if (typeof conf.value === 'number') api.addSlider(label, opts);
                   });
                }

                api.state = state; 
                // api.ui will be handled by the proxy getter to return 'this'
                api.then = (cb) => { if (cb) setTimeout(() => cb(api), 0); return api; };
                
                const proxy = new Proxy(api, { 
                    get: (t, p) => {
                        // DEFENSIVE: Return the proxy itself when 'ui' is requested
                        if (p === 'ui') return proxy;
                        if (p in t) return t[p];
                        // Fallback: Silent no-op for hallucinations
                        return (['canvas','ctx','controls'].includes(p) ? null : () => {});
                    }
                });
                window.WH._activeAppAPI = proxy;
                return window.WH._activeAppAPI;
            },

            createState: (initialObj) => {
                const listeners = new Set();
                const proxy = new Proxy(initialObj, {
                    set: (target, prop, value) => {
                        if (target[prop] === value) return true;

                        // REMOVED: JSON.stringify check. 
                        // It breaks on Generators, DOM nodes, and circular refs.
                        // It is also too slow for 60fps physics state.

                        target[prop] = value;
                        listeners.forEach(fn => fn(prop, value)); // Notify listeners
                        
                        window.dispatchEvent(new CustomEvent('widget-state-update', { 
                            detail: { key: prop, value: value } 
                        }));
                        return true;
                    }
                });
                proxy._subscribe = (fn) => listeners.add(fn);
                
                window.WH._activeState = proxy;
                return proxy;
            },

            el: (e) => window.WH._el(e),
            setText: (id, t) => { const e = window.WH._el(id); if(e) e.textContent = t; },
            on: (id, ev, fn) => { const e = window.WH._el(id); if(e) e.addEventListener(ev, fn); },
            
            renderMath: (idOrEl, latex) => {
                if(!window.katex) return;
                const el = window.WH._el(idOrEl); 
                if(!el) return;
                try { 
                    katex.render(latex, el, { throwOnError: false }); 
                } catch(e) { 
                    el.textContent = latex; 
                }
            },

            getColor: (v) => {
                if (!v) return 'transparent';
                if (v === 'transparent' || v.startsWith('#') || v.startsWith('rgb') || v.startsWith('hsl')) return v;


                let key = v.toLowerCase().trim();
                if (!key.startsWith('--')) key = '--' + key;


                const TOKENS = {
                    '--bg': '--surface', '--background': '--surface', '--main-bg': '--surface',
                    '--panel': '--surface-container', '--bg-panel': '--surface-container',
                    '--card': '--surface-container', '--card-bg': '--surface-container', 
                    '--modal': '--surface-container-high',

                    '--text': '--on-surface-default', '--foreground': '--on-surface-default', '--fg': '--on-surface-default',
                    '--text-primary': '--on-surface-default', '--header': '--on-surface-default',
                    '--text-secondary': '--on-surface-de-emphasis', '--subheader': '--on-surface-de-emphasis',
                    '--text-muted': '--on-surface-de-emphasis', '--muted': '--on-surface-de-emphasis',
                    
                    '--on-surface-variant': '--on-surface-de-emphasis',
                    '--on-surface-medium': '--on-surface-de-emphasis',

                    '--accent': '--primary', '--brand': '--primary', '--info': '--primary',
                    '--highlight-bg': '--highlight', '--selection': '--highlight',

                    '--border': '--stroke-default', '--divider': '--stroke-default', '--separator': '--stroke-default',
                    '--border-active': '--stroke-emphasis',

                    '--success': '--positive', '--green': '--positive', '--bg-success': '--positive-surface',
                    '--error': '--negative', '--danger': '--negative', '--red': '--negative', '--bg-error': '--negative-surface',
                    '--warning': '--chart-3', '--orange': '--chart-3', '--yellow': '--chart-3', 
                    
                    '--grey': '--stroke-emphasis', '--gray': '--stroke-emphasis',
                    '--neutral': '--surface-container-high',

                    '--chart-blue': '--blue', '--chart-green': '--green', '--chart-yellow': '--yellow',
                    '--chart-red': '--red', '--chart-purple': '--purple', '--chart-orange': '--orange',
                };

                const target = TOKENS[key] || key;

                let c = getComputedStyle(document.documentElement).getPropertyValue(target).trim();

                if (!c) {
                    if (key.includes('text') || key.includes('fg') || key.includes('on-surface')) c = getComputedStyle(document.documentElement).getPropertyValue('--on-surface-default').trim();
                    else if (key.includes('bg') || key.includes('surface')) c = getComputedStyle(document.documentElement).getPropertyValue('--surface').trim();
                    else if (key.includes('border')) c = getComputedStyle(document.documentElement).getPropertyValue('--stroke-default').trim();
                    else c = getComputedStyle(document.documentElement).getPropertyValue('--primary').trim();
                }

                return c;
            },
            
            transparent: (c, op) => {
                if (window.d3 && d3.color) {
                    const col = d3.color(window.WH.getColor(c));
                    if(col) { col.opacity = op; return col.toString(); }
                }
                return window.WH.getColor(c);
            },

            createTextSprite: (text, fontsize = 24) => {
                if (!window.THREE) return null;
                
                const padding = 12;
                const border = 4;
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                ctx.font = 'bold ' + fontsize + 'px sans-serif';
                const metrics = ctx.measureText(text);
                const textWidth = metrics.width;
                
                const w = textWidth + (padding * 2);
                const h = fontsize + (padding * 2);
                canvas.width = w;
                canvas.height = h;
                
                ctx.fillStyle = "rgba(20, 20, 20, 0.75)"; // High contrast pill
                ctx.beginPath();
                if (ctx.roundRect) {
                    ctx.roundRect(0, 0, w, h, h/2);
                } else {
                    // Fallback for older browsers
                    ctx.rect(0, 0, w, h);
                }
                ctx.fill();
                
                ctx.font = 'bold ' + fontsize + 'px sans-serif';
                ctx.fillStyle = "#ffffff";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(text, w/2, h/2 + 2); // +2 adjustment for visual center

                const texture = new THREE.CanvasTexture(canvas);
                texture.minFilter = THREE.LinearFilter;
                
                const material = new THREE.SpriteMaterial({ 
                    map: texture, 
                    transparent: true,
                    depthTest: false
                });
                
                const sprite = new THREE.Sprite(material);
                
                const scaleFactor = 0.02 * (fontsize / 24); 
                sprite.scale.set(w * scaleFactor, h * scaleFactor, 1);
                
                return sprite;
            },
            
            _createSafeCtx: (realCtx, widthFn, heightFn) => {
                // 1. Retina Scaling Helpers
                let _scalingCanvas = null;
                let _scalingCtx = null;

                // 2. Lazy Clear State
                let _autoClearEnabled = true;
                let _hasCleared = false;

                // 3. Methods that output pixels (triggering a clear)
                const DRAW_METHODS = new Set([
                    'fillRect', 'strokeRect', 'clearRect', 
                    'fill', 'stroke', 
                    'fillText', 'strokeText', 
                    'drawImage', 'putImageData',
                    'drawTag'
                ]);

                return new Proxy(realCtx, {
                    get(target, prop) {
                        // DEFENSIVE: Smart Context Props
                        if (prop === 'width') return widthFn();
                        if (prop === 'height') return heightFn();
                        if (prop === 'center') return { x: widthFn()/2, y: heightFn()/2 };
                        
                        // INTERNAL CONTROLS
                        if (prop === 'setAutoClear') return (val) => { _autoClearEnabled = !!val; };
                        if (prop === '_resetLazyClear') return () => { _hasCleared = false; };

                        // TRAP: putImageData (Needs both Lazy Clear AND Retina Scaling)
                        if (prop === 'putImageData') {
                            return (imgData, dx, dy) => {
                                // A. Trigger Lazy Clear
                                if (_autoClearEnabled && !_hasCleared) {
                                    // Clear using raw canvas dims to be safe against transforms
                                    target.save();
                                    target.resetTransform();
                                    target.clearRect(0, 0, target.canvas.width, target.canvas.height);
                                    target.restore();
                                    _hasCleared = true;
                                }

                                // B. Handle Retina Scaling
                                const logicalWidth = widthFn();
                                const isLogicalSize = (Math.abs(imgData.width - logicalWidth) < 1);
                                const dpr = window.devicePixelRatio || 1;
                                
                                if (dpr > 1 && isLogicalSize) {
                                    if (!_scalingCanvas) {
                                        _scalingCanvas = document.createElement('canvas');
                                        _scalingCtx = _scalingCanvas.getContext('2d');
                                    }
                                    if (_scalingCanvas.width !== imgData.width || _scalingCanvas.height !== imgData.height) {
                                        _scalingCanvas.width = imgData.width;
                                        _scalingCanvas.height = imgData.height;
                                    }
                                    _scalingCtx.putImageData(imgData, 0, 0);
                                    // drawImage respects the context transform (unlike putImageData)
                                    target.drawImage(_scalingCanvas, dx, dy);
                                } else {
                                    target.putImageData(imgData, dx, dy);
                                }
                            };
                        }

                        const value = target[prop];
                        if (typeof value === 'function') {
                            return (...args) => {
                                // TRAP: General Drawing Methods
                                if (DRAW_METHODS.has(prop) && _autoClearEnabled && !_hasCleared) {
                                    if (prop !== 'clearRect') {
                                        target.save();
                                        target.resetTransform();
                                        target.clearRect(0, 0, target.canvas.width, target.canvas.height);
                                        target.restore();
                                    }
                                    _hasCleared = true;
                                }

                                // 1. NaN Protection
                                for (let arg of args) {
                                    if (typeof arg === 'number' && !Number.isFinite(arg)) return;
                                }
                                if (prop === 'arc' && args.length > 2 && args[2] < 0) args[2] = Math.abs(args[2]);
                                
                                return value.apply(target, args);
                            };
                        }
                        return value; 
                    },
                    set(target, prop, value) {
                        target[prop] = value;
                        return true;
                    }
                });
            },
            
            initCanvas: (ctr, onSetup, options = {}) => {
                let el = window.WH._getViz(ctr); if(!el) return;
                
                // DEFENSIVE: Check if a canvas already exists (e.g. Three.js background)
                let c = el.querySelector('canvas');
                let isOverlay = false;

                // If existing canvas is WebGL (Three.js), we must create a NEW canvas on top for 2D
                if (c && c.getAttribute('data-engine')) {
                    isOverlay = true;
                    c = document.createElement('canvas');
                    c.style.cssText = 'position:absolute;top:0;left:0;width:100%;height:100%;touch-action:none;pointer-events:none;'; // Pass clicks through
                    try { el.appendChild(c); } catch(e) { 
                        setTimeout(() => { try { el.appendChild(c); } catch(e2){} }, 0);
                    }
                } else if (c) {
                    // If it's just an old 2D canvas, replace it (standard reset behavior)
                    c.remove();
                    c = document.createElement('canvas');
                    c.style.cssText = 'position:absolute;top:0;left:0;width:100%;height:100%;touch-action:none;outline:none';
                    try { el.appendChild(c); } catch(e) { 
                        setTimeout(() => { try { el.appendChild(c); } catch(e2){} }, 0);
                    }
                } else {
                    // Fresh canvas
                    c = document.createElement('canvas');
                    c.style.cssText = 'position:absolute;top:0;left:0;width:100%;height:100%;touch-action:none;outline:none';
                    try { el.appendChild(c); } catch(e) { 
                        setTimeout(() => { try { el.appendChild(c); } catch(e2){} }, 0);
                    }
                }
                
                const realCtx = c.getContext('2d', { alpha: options.alpha !== false });

                if (!realCtx.roundRect) {
                    realCtx.roundRect = function(x, y, w, h, r) {
                        if (w < 2 * r) r = w / 2;
                        if (h < 2 * r) r = h / 2;
                        this.beginPath();
                        this.moveTo(x + r, y);
                        this.arcTo(x + w, y, x + w, y + h, r);
                        this.arcTo(x + w, y + h, x, y + h, r);
                        this.arcTo(x, y + h, x, y, r);
                        this.arcTo(x, y, x + w, y, r);
                        this.closePath();
                        return this;
                    };
                }

                realCtx.drawTag = (text, x, y, a4) => {
                    const themeFont = getComputedStyle(document.body).getPropertyValue('--ff-sans') || 'sans-serif';
                    realCtx.font = 'bold 12px ' + themeFont;
                    const w = realCtx.measureText(text).width + 16; const h = 24;
                    let dx = x; 
                    if (dx - w/2 < 4) dx = w/2 + 4;
                    if (dx + w/2 > c.width/(window.devicePixelRatio||1) - 4) dx = c.width/(window.devicePixelRatio||1) - w/2 - 4;
                    
                    realCtx.fillStyle = window.WH.getColor('--surface'); realCtx.globalAlpha = 0.9;
                    realCtx.beginPath(); realCtx.roundRect(dx - w/2, y - h/2, w, h, 12); realCtx.fill();
                    realCtx.fillStyle = window.WH.getColor(a4 || '--on-surface-default'); realCtx.globalAlpha = 1.0;
                    realCtx.textAlign = 'center'; realCtx.textBaseline = 'middle'; realCtx.fillText(text, dx, y);
                };
                
                const safeCtx = window.WH._createSafeCtx(realCtx, () => c.width / (window.devicePixelRatio||1), () => c.height / (window.devicePixelRatio||1));

                const existingCanvasListeners = new Set();
                const originalCanvasAddEventListener = c.addEventListener;
                c.addEventListener = (type, fn, options) => {
                    const key = type + fn.toString();
                    if (existingCanvasListeners.has(key)) return;
                    existingCanvasListeners.add(key);
                    originalCanvasAddEventListener.call(c, type, fn, options);
                };

                const pointer = { x: -1000, y: -1000, isDown: false, justPressed: false, justReleased: false };
                Object.defineProperties(pointer, {
                    'down': { get: () => pointer.isDown },
                    'up':   { get: () => pointer.justReleased }, 
                    'primary': { get: () => pointer.isDown },
                    // 1. Pixels (Standard)
                    'px': { get: () => pointer.x },
                    'py': { get: () => pointer.y },
                    // 2. Normalized 0 to 1 (Aliases: nx/ny AND uv)
                    'nx': { get: () => window.WH.clamp(pointer.x / (logicW||1), 0, 1) },
                    'ny': { get: () => window.WH.clamp(pointer.y / (logicH||1), 0, 1) },
                    'uv': { get: () => ({ x: window.WH.clamp(pointer.x / (logicW||1), 0, 1), y: window.WH.clamp(pointer.y / (logicH||1), 0, 1) }) },
                    // 3. Normalized -1 to 1 (Raycasting/Shader ready)
                    'ndc': { get: () => ({ x: (pointer.x / (logicW||1)) * 2 - 1, y: -(pointer.y / (logicH||1)) * 2 + 1 }) }
                });

                let logicW=0, logicH=0, offX=0, offY=0;

                const updatePointer = (e, isDownVal) => {
                     const clientX = (e.touches && e.touches.length > 0) ? e.touches[0].clientX : e.clientX;
                     const clientY = (e.touches && e.touches.length > 0) ? e.touches[0].clientY : e.clientY;
                     if (typeof clientX !== 'number') return;
                     const r = c.getBoundingClientRect();
                     pointer.x = (clientX - r.left) - offX;
                     pointer.y = (clientY - r.top) - offY;
                     if (isDownVal !== undefined) pointer.isDown = isDownVal;
                };
                c.addEventListener('mousedown', (e) => { pointer.justPressed = true; updatePointer(e, true); });
                c.addEventListener('mousemove', (e) => updatePointer(e));
                c.addEventListener('mouseup',   (e) => { pointer.isDown = false; pointer.justReleased = true; });
                c.addEventListener('mouseleave',(e) => { pointer.isDown = false; pointer.x = -1000; pointer.y = -1000; });
                c.addEventListener('touchstart', (e) => { pointer.justPressed = true; updatePointer(e, true); e.preventDefault(); }, {passive:false});
                c.addEventListener('touchmove',  (e) => { updatePointer(e); e.preventDefault(); }, {passive:false});
                c.addEventListener('touchend',   (e) => { pointer.isDown = false; pointer.justReleased = true; e.preventDefault(); }, {passive:false});

                let active=true, loopFn=null, isSetup=false;
                const updateSize = () => {
                     const r = el.getBoundingClientRect();
                     
                     // FIX: Defer setup until container is visible. 
                     if (r.width === 0 || r.height === 0) return;
                     
                     const dpr = window.devicePixelRatio || 1;
                     const W = r.width;
                     const H = r.height;
                     c.width = W * dpr; c.height = H * dpr;
                     
                     if (options.aspectRatio) {
                         if (W / H > options.aspectRatio) { logicH = H; logicW = H * options.aspectRatio; offX = (W - logicW) / 2; offY = 0; }
                         else { logicW = W; logicH = W / options.aspectRatio; offX = 0; offY = (H - logicH) / 2; }
                     } else { logicW = W; logicH = H; offX = 0; offY = 0; }

                     if (!isSetup) {
                         isSetup = true;
                         try { 
                             // DEFENSIVE: Support ({ ctx, width }) in setup
                             if (safeCtx) {
                                 safeCtx.ctx = safeCtx;
                                 safeCtx.width = logicW;
                                 safeCtx.height = logicH;
                                 safeCtx.pointer = pointer;
                             }
                             loopFn = onSetup(safeCtx, logicW, logicH, pointer); 
                         } catch(e) { window.WH.showError(e.message); active=false; }
                     }
                };
                new ResizeObserver(updateSize).observe(el); 

                let lastTime = null;
                const MAX_FRAME_TIME = 100; 
                let consecutivelySlowFrames = 0;
                
                const loop = (t) => {
                    if(!active) return;
                    const start = performance.now();
                    if (lastTime === null) lastTime = t;
                    const dtMs = Math.min(t - lastTime, 100); 
                    lastTime = t;

                    if (isSetup && typeof loopFn === 'function') {
                        const dpr = window.devicePixelRatio || 1;
                        realCtx.resetTransform();
                        safeCtx._resetLazyClear();
                        
                        realCtx.setTransform(dpr, 0, 0, dpr, offX * dpr, offY * dpr);
                        
                        realCtx.globalAlpha = 1.0;
                        realCtx.lineWidth = 1;
                        realCtx.shadowBlur = 0;
                        realCtx.lineJoin = 'miter';
                        realCtx.lineCap = 'butt';
                        const themeFont = getComputedStyle(document.body).getPropertyValue('--ff-sans') || 'sans-serif';
                        realCtx.font = '500 14px ' + themeFont; 
                        realCtx.textBaseline = 'middle';
                        realCtx.textAlign = 'left';
                        realCtx.fillStyle = window.WH.getColor('--on-surface-default');
                        realCtx.strokeStyle = window.WH.getColor('--stroke-default');

                        if (options.aspectRatio) { realCtx.beginPath(); realCtx.rect(0, 0, logicW, logicH); realCtx.clip(); }

                        try {
                             const tSec = t / 1000;
                             const dtSec = dtMs / 1000;
                             if (loopFn.length === 1) {
                                 loopFn({ 
                                     ctx: safeCtx, 
                                     width: logicW, 
                                     height: logicH, 
                                     time: tSec, 
                                     dt: dtSec, 
                                     pointer,
                                     state: window.WH._activeState
                                 });
                             }
                             else if (loopFn.length === 2) loopFn(tSec, dtSec);
                             else loopFn(safeCtx, logicW, logicH, tSec, dtSec, pointer);
                        } catch(e) { window.WH.showError(e.message); active=false; }
                        pointer.justPressed = false;
                        pointer.justReleased = false;
                    }

                    const end = performance.now();
                    if (end - start > MAX_FRAME_TIME) {
                        consecutivelySlowFrames++;
                        if (consecutivelySlowFrames > 5) {
                            active = false;
                            window.WH.showError("Widget stopped: Low performance / Infinite loop detected.");
                            return; 
                        }
                    } else {
                        consecutivelySlowFrames = 0;
                    }

                    requestAnimationFrame(loop);
                };
                requestAnimationFrame(loop);
                return { canvas: c, ctx: safeCtx, stop: () => active=false };
            },

            // B. D3 (Flexible: SVG or DOM)
            initD3: (id, onSetup) => {
                 const el = window.WH._getViz(id); if(!el) return;
                 
                 const proxyUpdate = (...args) => {
                     if (userUpdate) {
                         try { userUpdate(...args); } catch(e) { window.WH.showError(e.message); }
                     } else {
                         pendingArgs = args;
                     }
                 };
                 
                 const selection = d3.select(el);
                 
                 if (!('clientWidth' in selection)) {
                     Object.defineProperty(selection, 'clientWidth', { get: () => el.clientWidth });
                     Object.defineProperty(selection, 'clientHeight', { get: () => el.clientHeight });
                     Object.defineProperty(selection, 'getBoundingClientRect', { value: () => el.getBoundingClientRect() });
                 }
                 
                 let isSetup = false, userUpdate = null, pendingArgs = null;
                 let curW = 0, curH = 0;

                  const render = () => {
                     const r = el.getBoundingClientRect();
                     
                     if (r.width === 0 && r.height === 0) return; 
                     
                     const safeW = r.width || 300;
                     const safeH = r.height || 200;
                     
                     curW = safeW; curH = safeH;
                         
                     selection.select('svg')
                        .attr('width', '100%').attr('height', '100%')
                        .attr('viewBox', [0, 0, safeW, safeH]);
                            
                     if (!isSetup) {
                         isSetup = true;
                         try { 
                            // DEFENSIVE: Support ({ selection, width }) signature
                            if (selection && typeof selection === 'object') {
                                selection.selection = selection;
                                selection.width = safeW;
                                selection.height = safeH;
                            }
                             const result = onSetup(selection, safeW, safeH); 
                                 
                                 if (typeof result === 'function') {
                                     userUpdate = result;
                                     try { userUpdate(); } catch(e) { window.WH.showError(e.message); }
                                 } else {
                                     userUpdate = () => {
                                         // Clear and re-run setup with latest dimensions
                                         el.innerHTML = '';
                                         onSetup(selection, curW, curH);
                                     };
                                 }

                                 if (pendingArgs && userUpdate) {
                                     userUpdate(...pendingArgs);
                                     pendingArgs = null;
                                 }
                             } 
                             catch(e) { window.WH.showError(e.message); }
                         }
                 };
                 new ResizeObserver(() => requestAnimationFrame(render)).observe(el);
                 return proxyUpdate;
            },
            
            // C. PLOT (Stable Sizing)
            initPlot: (id, getOptions) => {
                if (!window.Plot) return;
                const el = window.WH._getViz(id); if (!el) return;
                el.style.position = 'relative'; el.style.overflow = 'hidden'; // Force clipping
                const c = window.WH.getColor;
                
                const render = async () => {
                    if (!el.isConnected) return;
                    const rect = el.getBoundingClientRect();
                    // Plot requires valid dimensions
                    if (rect.width === 0 || rect.height === 0) return;
                    const w = Math.floor(rect.width); 
                    const h = Math.floor(rect.height);

                    let result; 
                    try { 
                        result = getOptions(w, h); 
                        if (typeof result === 'function') result = result();
                        
                       // FIX: Handle async config (e.g. fetching data inside plot setup)
                       if (result instanceof Promise) result = await result;
                    } 
                    catch (e) { 
                        return; 
                    }

                    const theme = {
                        style: { background: 'transparent', color: c('--on-surface-default'), fontFamily: c('--ff-sans'), fontSize: '13px', overflow: 'visible' },
                        marginLeft: 50, marginBottom: 40,
                        marginRight: 20, // <--- ADD THIS (Safety margin)
                        color: { range: [c('--chart-1'), c('--chart-2'), c('--chart-3'), c('--chart-4'), c('--chart-5')], unknown: c('--on-surface-de-emphasis') }
                    };

                    let chartNode;
                    try { 
                       // Handle DOM Node (Manual Plot) vs Config Object (Standard)
                       if (result instanceof Element || (result && result.nodeType)) {
                           chartNode = result;
                       } else if (typeof result === 'object' && result !== null) {
                           chartNode = Plot.plot({ ...theme, ...result, width: w, height: h });
                       }

                       if (chartNode) {
                           chartNode.style.display = 'block';
                           chartNode.style.maxWidth = '100%';
                           chartNode.style.maxHeight = '100%';
                           el.replaceChildren(chartNode); 
                       }
                    } catch (e) {
                        return;
                    }
                };
                new ResizeObserver(render).observe(el);
                requestAnimationFrame(render);
                
                // AUTO-SUBSCRIBE to State
                if (window.WH._activeState) {
                    window.WH._activeState._subscribe(() => requestAnimationFrame(render));
                }

                return render;
            },
            
            initThree: (ctr, onSetup) => {
                if (!window.THREE) return;
                window.WH.addBadge('3d_rotation', 'Rotate & Zoom', true);
                const el = window.WH._getViz(ctr); if(!el) return;
                const existing = el.querySelector('canvas'); if (existing) existing.remove();
                const c = document.createElement('canvas');
                c.setAttribute('data-engine', 'three'); // Mark as WebGL layer
                c.style.cssText = 'position:absolute;top:0;left:0;width:100%;height:100%;touch-action:none;outline:none';
                el.appendChild(c);
                
                const p = { x: -1000, y: -1000, ndc: {x:0, y:0}, isDown: false, justPressed: false, justReleased: false };
                
                const smartPointer = {
                    // 1. Pixels (Standard - Fixes Rotation Bug)
                    get x() { return p.x; },
                    get y() { return p.y; },
                    
                    // 2. Normalized 0 to 1 (Aliases for consistency)
                    get nx() { return (p.ndc.x + 1) / 2; },
                    get ny() { return (p.ndc.y + 1) / 2; },
                    get uv() { return { x: (p.ndc.x + 1) / 2, y: (p.ndc.y + 1) / 2 }; },

                    // 3. Normalized -1 to 1 (Raycasting)
                    get ndc() { return p.ndc; }, 

                    get isDown() { return p.isDown; },
                    get justPressed() { return p.justPressed; },
                    get justReleased() { return p.justReleased; }
                };

                const updatePointer = (e) => {
                      const r = c.getBoundingClientRect(); if (r.width <= 0) return;
                      p.x = e.clientX - r.left; p.y = e.clientY - r.top;
                      p.ndc.x = (p.x / r.width) * 2 - 1; p.ndc.y = -(p.y / r.height) * 2 + 1;
                };

                c.addEventListener('pointermove', updatePointer);
                c.addEventListener('pointerdown', (e) => { 
                    p.isDown = true; p.justPressed = true; 
                    updatePointer(e); c.setPointerCapture(e.pointerId); 
                });
                c.addEventListener('pointerup', (e) => { 
                    p.isDown = false; p.justReleased = true; 
                    c.releasePointerCapture(e.pointerId); 
                });
                c.addEventListener('pointercancel', () => p.isDown = false);

                const scene = new THREE.Scene();
                const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 1000); camera.position.set(0,0,40);
                const renderer = new THREE.WebGLRenderer({ canvas: c, alpha: true, antialias: true });
                renderer.setPixelRatio(window.devicePixelRatio);
                const controls = (THREE.OrbitControls) ? new THREE.OrbitControls(camera, c) : { update:()=>{}, target:new THREE.Vector3() };

                let onTick = null, onStop = null, isSetup = false, active = true;
                
                const updateSize = () => {
                    const r = el.getBoundingClientRect();
                    if (r.width > 0 && r.height > 0) {
                        camera.aspect = r.width / r.height; camera.updateProjectionMatrix();
                        renderer.setSize(r.width, r.height, false);
                        if (!isSetup) {
                            isSetup = true;
                            try { 
                                const args = [scene, camera, renderer, controls, smartPointer];
                                // DEFENSIVE: Attach props to scene to support ({ scene, camera }) destructuring
                                if (scene && typeof scene === 'object') {
                                    scene.scene = scene;
                                    scene.camera = camera;
                                    scene.renderer = renderer;
                                    scene.controls = controls;
                                    scene.pointer = smartPointer;
                                }
                                const result = onSetup(...args);
                                if (typeof result === 'function') onTick = result;
                                else if (result && typeof result.loop === 'function') { onTick = result.loop; if(result.stop) onStop = result.stop; }
                            } catch(e) { window.WH.showError(e.message); active=false; }
                        }
                    }
                };
                new ResizeObserver(updateSize).observe(el);

                let lastTime = null;
                const loop = (t) => {
                    if(!active) return;
                    if (lastTime === null) lastTime = t;
                    const dt = Math.min(t - lastTime, 50) / 1000; lastTime = t;
                    if(isSetup) {
                        controls.update();
                        if(typeof onTick === 'function') {
                            const cvs = renderer.domElement;
                            const dpr = window.devicePixelRatio || 1;
                            try { 
                                onTick({ 
                                    time: t/1000, 
                                    dt, 
                                    pointer: smartPointer, 
                                    state: window.WH._activeState, 
                                    width: cvs.width/dpr, 
                                    height: cvs.height/dpr 
                                }); 
                            } 
                            catch(e) { window.WH.showError(e.message); active=false; }
                        }
                        p.justPressed = false; p.justReleased = false;
                        
                        renderer.render(scene, camera);
                    }
                    requestAnimationFrame(loop);
                };
                requestAnimationFrame(loop);
                return { scene, camera, renderer, controls, stop: () => { active = false; if (onStop) onStop(); renderer.dispose(); } };
            },
            
            initPhysics: (ctr, optionsOrUpdate, legacyOnReady) => {
                 if(!window.Matter) return;
                 let onUpdate, onRender, onReady;
                 
                 if (typeof optionsOrUpdate === 'function') {
                     onUpdate = optionsOrUpdate; onReady = legacyOnReady;
                 } else if (optionsOrUpdate) {
                     onUpdate = optionsOrUpdate.onUpdate;
                     onRender = optionsOrUpdate.onRender;
                     onReady = optionsOrUpdate.onReady;
                 }

                 if (onUpdate && onUpdate.length >= 3) {
                     /* console.warn("WH: Auto-fixing physics loop signature"); */
                     onRender = onUpdate;
                     onUpdate = null;
                 }

                 let el = window.WH._getViz(ctr); if(!el) return;
                 const existing = el.querySelector('canvas'); if (existing) existing.remove();
                 
                 const engine = Matter.Engine.create();
                 const render = Matter.Render.create({
                    element: el, engine: engine,
                    options: { width: 100, height: 100, pixelRatio: window.devicePixelRatio, background: 'transparent', wireframes: false }
                 });
                 render.canvas.style.cssText = 'position:absolute;top:0;left:0;width:100%;height:100%;touch-action:none';
                 
                 const mouse = Matter.Mouse.create(render.canvas);
                 const mouseConstraint = Matter.MouseConstraint.create(engine, { mouse: mouse, constraint: { stiffness: 0.2, render: { visible: false } } });
                 Matter.World.add(engine.world, mouseConstraint);
                 render.mouse = mouse;

                 let isInitialized = false;
                 const update = () => {
                    const r = el.getBoundingClientRect();
                    // Physics Safety: Defer init until visible
                    if (r.width > 0 && r.height > 0) {
                         render.options.width = r.width; render.options.height = r.height;
                         render.canvas.width = r.width * window.devicePixelRatio;
                         render.canvas.height = r.height * window.devicePixelRatio;
                         if(!isInitialized && onReady) {
                             isInitialized = true;
                             try { 
                                 // DEFENSIVE: If fn expects 1 arg, pass object. Else pass primitives.
                                 if (onReady.length === 1) {
                                     onReady({ width: r.width, height: r.height, engine, render });
                                 } else {
                                     onReady(r.width, r.height, engine, render); 
                                 }
                             } catch(e) { window.WH.showError(e.message); }
                         }
                    }
                 };
                 new ResizeObserver(update).observe(el); requestAnimationFrame(update);
                 
                 if (onUpdate) {
                    Matter.Events.on(engine, 'beforeUpdate', (event) => {
                        const dt = Math.min(event.source.timing.lastDelta, 100);
                        try { onUpdate(event.source, dt); } 
                        catch(e) { window.WH.showError(e.message); }
                    });
                }
                 if (onRender) {
                    const safePhysicsCtx = window.WH._createSafeCtx(
                        render.context, 
                        () => render.options.width, 
                        () => render.options.height
                    );
                    Matter.Events.on(render, 'afterRender', () => {
                        try {
                            onRender(
                                safePhysicsCtx, 
                                render.options.width, 
                                render.options.height, 
                                engine
                            ); 
                        } catch(e) { window.WH.showError(e.message); }
                    });
                 }
                 Matter.Render.run(render);
                 const runner = Matter.Runner.create();
                 Matter.Runner.run(runner, engine);
                 
                 return { engine, world: engine.world, runner, render, mouseConstraint, stop: () => { Matter.Render.stop(render); Matter.Runner.stop(runner); }};
            }
        };
    </script>
</head>
<body style="height: 100%; display: flex; flex-direction: column; overflow: hidden; background: var(--surface); margin: 0px;">javascript
<script>
/**
 * IT-OT Security Pipeline Visualization
 * An interactive flow diagram showing data integrity from Edge (Drone) to Blockchain (Ethereum).
 */

// 1. Setup App (UI + State)
const { state, ui } = WH.createApp({
    title: "IT-OT Security Pipeline",
    params: {
        flowSpeed: { value: 0.8, min: 0.1, max: 2, label: "Animation Speed" },
        spawnRate: { value: 1.5, min: 0.5, max: 5, label: "Data Frequency (s)" },
        showPayload: { value: true, label: "Show Data Details" },
        // Internal State
        anchoredCount: 0,
        isRunning: true
    }
});

// 2. Define Pipeline Architecture
const nodes = [
    { id: 'drone', label: 'Industrial Drone', icon: '', sub: 'Modbus / Telemetry', color: '--chart-1' },
    { id: 'keri', label: 'KERI Agent', icon: '', sub: 'SAID / Signing', color: '--chart-5' },
    { id: 'file', label: 'Anchor File', icon: '', sub: 'Local JSON Vault', color: '--chart-3' },
    { id: 'bridge', label: 'Python Bridge', icon: '', sub: 'Broadcast Service', color: '--chart-2' },
    { id: 'eth', label: 'Ethereum Contract', icon: '', sub: 'Immutable Record', color: '--primary' }
];

// Data packet storage
const packets = [];
let lastSpawnTime = 0;
let lastFlashTime = -1;

// 3. Logic: Add manual trigger
ui.addAction('Manual Trigger', () => {
    spawnPacket();
});

function spawnPacket() {
    packets.push({
        progress: 0, // 0 to 4 (index of segments)
        segment: 0,  // Which gap it is currently in
        val: (Math.random() * 100).toFixed(1),
        id: Math.random().toString(36).substr(2, 5).toUpperCase()
    });
}

// 4. Initialize Visualization
WH.initCanvas('viz', (ctx) => {
    // Setup - Runs once
    WH.addBadge('touch_app', 'Interactive Flow');

    // Render Loop - Runs 60fps
    return ({ ctx, width, height, time, dt, state }) => {
        const padding = 60;
        const centerY = height * 0.5;
        const nodeSpacing = (width - padding * 2) / (nodes.length - 1);

        // A. Update Logic
        if (state.isRunning) {
            // Auto-spawn packets based on state.spawnRate
            if (time - lastSpawnTime > state.spawnRate) {
                spawnPacket();
                lastSpawnTime = time;
            }

            // Move Packets
            for (let i = packets.length - 1; i >= 0; i--) {
                const p = packets[i];
                p.progress += dt * state.flowSpeed;

                // Check if packet reached next node
                if (p.progress >= 1) {
                    p.segment++;
                    p.progress = 0;

                    // Final node reached (Ethereum)
                    if (p.segment >= nodes.length - 1) {
                        state.anchoredCount++;
                        lastFlashTime = time;
                        ui.setStatus(`Total Records Anchored: ${state.anchoredCount}`);
                        packets.splice(i, 1);
                    }
                }
            }
        }

        // B. Draw Connections (Background Lines)
        ctx.setLineDash([5, 5]);
        ctx.strokeStyle = WH.transparent('--on-surface-default', 0.2);
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(padding, centerY);
        ctx.lineTo(width - padding, centerY);
        ctx.stroke();
        ctx.setLineDash([]); // Reset dash

        // C. Draw Nodes
        nodes.forEach((node, i) => {
            const x = padding + i * nodeSpacing;
            const isLast = i === nodes.length - 1;
            
            // Highlight Ethereum node if recently anchored
            const isFlashing = isLast && (time - lastFlashTime < 0.5);
            const nodeColor = isFlashing ? '--positive' : node.color;
            const scale = isFlashing ? 1.1 : 1.0;

            // Draw Connection Circle
            ctx.fillStyle = WH.getColor(nodeColor);
            ctx.beginPath();
            ctx.arc(x, centerY, 8 * scale, 0, Math.PI * 2);
            ctx.fill();

            // Draw Node Box/Tag
            const tagY = i % 2 === 0 ? centerY - 50 : centerY + 50;
            ctx.drawTag(`${node.icon} ${node.label}`, x, tagY);
            
            // Subtext
            ctx.fillStyle = WH.transparent('--on-surface-default', 0.6);
            ctx.font = '10px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(node.sub, x, tagY + (i % 2 === 0 ? -20 : 25));
        });

        // D. Draw Packets (Animated Dots)
        packets.forEach(p => {
            const startX = padding + p.segment * nodeSpacing;
            const endX = padding + (p.segment + 1) * nodeSpacing;
            const currentX = startX + (endX - startX) * p.progress;
            
            // Packet Glow
            const gradient = ctx.createRadialGradient(currentX, centerY, 0, currentX, centerY, 15);
            gradient.addColorStop(0, WH.transparent('--primary', 0.4));
            gradient.addColorStop(1, 'transparent');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(currentX, centerY, 15, 0, Math.PI * 2);
            ctx.fill();

            // Packet Body
            ctx.fillStyle = WH.getColor('--primary');
            ctx.beginPath();
            ctx.arc(currentX, centerY, 5, 0, Math.PI * 2);
            ctx.fill();

            // Packet Label (Payload)
            if (state.showPayload) {
                ctx.fillStyle = WH.getColor('--on-surface-default');
                ctx.font = 'bold 9px monospace';
                ctx.textAlign = 'center';
                
                let dataLabel = "";
                if (p.segment === 0) dataLabel = `MODBUS:${p.val}`;
                else if (p.segment === 1) dataLabel = `SAID:${p.id}`;
                else if (p.segment === 2) dataLabel = `JSON_HASH`;
                else dataLabel = `TX_PROP`;

                ctx.fillText(dataLabel, currentX, centerY - 15);
            }
        });

        // E. Legend/Overlay
        ctx.drawTag(`Pipeline Status: ${state.isRunning ? 'ACTIVE' : 'PAUSED'}`, 80, 30);
    };
});

// Initial Status
ui.setStatus("Security Pipeline Online. Monitoring drone telemetry...");

</script><div class="widget-ui-part flex justify-between items-center px-m py-s border-b bg-surface shrink-0 flex-wrap gap-s"><h3 class="text-sm fw-bold m-0" style="font-size:1rem;">IT-OT Security Pipeline</h3><div id="app-status" class="caption font-mono">Total Records Anchored: 20</div></div><div id="viz" class="widget-ui-part viz-container grow bg-surface-container relative overflow-hidden"><div id="viz-badges" class="viz-badges" data-user-modified="true"><div class="badge"><span class="material-icons">touch_app</span> Interactive Flow</div></div><canvas style="position: absolute; top: 0px; left: 0px; width: 100%; height: 100%; touch-action: none; outline: none;" width="528" height="300"></canvas></div><div id="controls-root" class="widget-ui-part p-m border-t bg-surface shrink-0 w-full control-grid"><div class="xxs-row standard compact" data-key="flowSpeed"><label class="xxs-label" for="ctrl-nyafh">Animation Speed</label><div class="xxs-slider-wrap"><input type="range" class="xxs-slider" min="0.1" max="2" step="0.1" id="ctrl-nyafh" style="--progress: 36.8421052631579%;"></div><input type="number" class="xxs-val-pill" min="0.1" max="2" step="0.1"></div><div class="xxs-row standard compact" data-key="spawnRate"><label class="xxs-label" for="ctrl-dfvt1">Data Frequency (s)</label><div class="xxs-slider-wrap"><input type="range" class="xxs-slider" min="0.5" max="5" step="0.1" id="ctrl-dfvt1" style="--progress: 22.22222222222222%;"></div><input type="number" class="xxs-val-pill" min="0.5" max="5" step="0.1"></div><div class="xxs-row compact input"><div class="xxs-label" style="flex-grow: 1;">Show Data Details</div><div class="xxs-switch active" role="switch" tabindex="0" aria-checked="true"><div class="knob"></div></div></div><div class="xxs-row compact xxs-button-cell" style="display: flex; gap: 8px;"><button class="xxs-btn " style="width: 100%; flex: 1 1 0%;">Manual Trigger</button></div></div>

</body></html>